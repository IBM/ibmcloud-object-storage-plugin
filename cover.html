
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM/ibmcloud-object-storage-plugin/driver/driver.go (89.5%)</option>
				
				<option value="file1">github.com/IBM/ibmcloud-object-storage-plugin/utils/backend/backend.go (100.0%)</option>
				
				<option value="file2">github.com/IBM/ibmcloud-object-storage-plugin/utils/config/config.go (95.1%)</option>
				
				<option value="file3">github.com/IBM/ibmcloud-object-storage-plugin/utils/logger/logger.go (97.8%)</option>
				
				<option value="file4">github.com/IBM/ibmcloud-object-storage-plugin/utils/parser/parser.go (96.0%)</option>
				
				<option value="file5">github.com/IBM/ibmcloud-object-storage-plugin/utils/uuid/uuid.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package driver

import (
        "crypto/sha256"
        "errors"
        "fmt"
        "github.com/IBM/ibmcloud-object-storage-plugin/driver/interfaces"
        "github.com/IBM/ibmcloud-object-storage-plugin/utils/backend"
        "github.com/IBM/ibmcloud-object-storage-plugin/utils/parser"
        "go.uber.org/zap"
        "io/ioutil"
        "os"
        "os/exec"
        "path"
        "path/filepath"
        "strconv"
        "strings"
        "syscall"
)

const (
        dataRootPath          = "/var/lib/ibmc-s3fs"
        passwordFileName      = "passwd"
        cacheDirectoryName    = "cache"
        defaultTLSCipherSuite = "AES"
        caPath                = "/tmp"
        // SecretAccessKey is the key name for the AWS Access Key
        SecretAccessKey = "access-key"
        // SecretSecretKey is the key name for the AWS Secret Key
        SecretSecretKey = "secret-key"
        // SecretAPIKey is the key name for the IBM API Key (IAM Authentication)
        SecretAPIKey = "api-key"
        //SecretAllowedNS is the key name for the Allowed Namespace
        SecretAllowedNS = "allowed_ns"
        // SecretServiceInstanceID is the key name for the service instance ID (IAM Authentication)
        SecretServiceInstanceID = "service-instance-id"
        // defaultIAMEndPoint is the default URL of the IBM IAM endpoint
        defaultIAMEndPoint = "https://iam.bluemix.net"
        // CrtBundle is the base64 encoded crt bundle
        CrtBundle = "ca-bundle-crt"
)

var (
        command            = exec.Command
        stat               = os.Stat
        unmount            = syscall.Unmount
        mount              = syscall.Mount
        writeFile          = ioutil.WriteFile
        mkdirAll           = os.MkdirAll
        removeAll          = os.RemoveAll
        hostname, anyerror = os.Hostname()
)

// buildVersion holds the driver version string
var buildVersion = ""
var podUID = ""

// Options are the FlexVolume driver options
type Options struct {
        ChunkSizeMB             int    `json:"chunk-size-mb,string"`
        ParallelCount           int    `json:"parallel-count,string"`
        MultiReqMax             int    `json:"multireq-max,string"`
        StatCacheSize           int    `json:"stat-cache-size,string"`
        FSGroup                 string `json:"kubernetes.io/fsGroup,omitempty"`
        FSGroupNew              string `json:"kubernetes.io/mounterArgs.FsGroup,omitempty"`
        Endpoint                string `json:"endpoint,omitempty"` //Will be deprecated
        Region                  string `json:"region,omitempty"`   //Will be deprecated
        Bucket                  string `json:"bucket"`
        ObjectPath              string `json:"object-path,omitempty"`
        DebugLevel              string `json:"debug-level"`
        CurlDebug               bool   `json:"curl-debug,string"`
        KernelCache             bool   `json:"kernel-cache,string,omitempty"`
        TLSCipherSuite          string `json:"tls-cipher-suite,omitempty"`
        S3FSFUSERetryCount      string `json:"s3fs-fuse-retry-count,omitempty"`
        StatCacheExpireSeconds  string `json:"stat-cache-expire-seconds,omitempty"`
        AccessKeyB64            string `json:"kubernetes.io/secret/access-key,omitempty"`
        SecretKeyB64            string `json:"kubernetes.io/secret/secret-key,omitempty"`
        APIKeyB64               string `json:"kubernetes.io/secret/api-key,omitempty"`
        OSEndpoint              string `json:"object-store-endpoint,omitempty"`
        OSStorageClass          string `json:"object-store-storage-class,omitempty"`
        IAMEndpoint             string `json:"iam-endpoint,omitempty"`
        ConnectTimeoutSeconds   string `json:"connect-timeout,omitempty"`
        ReadwriteTimeoutSeconds string `json:"readwrite-timeout,omitempty"`
        UseXattr                bool   `json:"use-xattr,string,omitempty"`
        AccessMode              string `json:"access-mode,omitempty"`
        ServiceInstanceIDB64    string `json:"kubernetes.io/secret/service-instance-id,omitempty"`
        CAbundleB64             string `json:"kubernetes.io/secret/ca-bundle-crt,omitempty"`
        CosServiceIP            string `json:"service-ip,omitempty"`
        AutoCache               bool   `json:"auto_cache,string,omitempty"`
}

// PathExists returns true if the specified path exists.
func pathExists(path string) (bool, error) <span class="cov9" title="33">{
        if path == "" </span><span class="cov3" title="3">{
                return false, errors.New("Undefined path")
        }</span>
        <span class="cov9" title="30">_, err := os.Stat(path)
        if err == nil </span><span class="cov2" title="2">{
                return true, nil
        }</span> else<span class="cov9" title="28"> if os.IsNotExist(err) </span><span class="cov9" title="28">{
                return false, nil
        }</span> else<span class="cov0" title="0"> if isCorruptedMnt(err) </span><span class="cov0" title="0">{
                return true, err
        }</span> else<span class="cov0" title="0"> {
                return false, err
        }</span>
}

// isCorruptedMnt return true if err is about corrupted mount point
func isCorruptedMnt(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var underlyingError error
        switch pe := err.(type) </span>{
        case nil:<span class="cov0" title="0">
                return false</span>
        case *os.PathError:<span class="cov0" title="0">
                underlyingError = pe.Err</span>
        case *os.LinkError:<span class="cov0" title="0">
                underlyingError = pe.Err</span>
        case *os.SyscallError:<span class="cov0" title="0">
                underlyingError = pe.Err</span>
        }
        <span class="cov0" title="0">return underlyingError == syscall.ENOTCONN || underlyingError == syscall.ESTALE</span>
}

// S3fsPlugin supports mount &amp; unmount requests of s3fs volumes
type S3fsPlugin struct {
        Backend backend.ObjectStorageSessionFactory
        Logger  *zap.Logger
}

// SetBuildVersion sets the driver version
func SetBuildVersion(version string) <span class="cov0" title="0">{
        buildVersion = version
}</span>

// SetPodUID sets the POD UID
func SetPodUID(poduid string) <span class="cov0" title="0">{
        podUID = poduid
}</span>

// isMountpoint return true if pathname is a mountpoint
func (p *S3fsPlugin) isMountpoint(pathname string) (bool, error) <span class="cov5" title="6">{
        p.Logger.Info(podUID+":"+"Checking if path is mountpoint",
                zap.String("Pathname", pathname))

        out, err := command("mountpoint", pathname).CombinedOutput()
        outStr := strings.TrimSpace(string(out))
        if err != nil </span><span class="cov1" title="1">{
                if strings.HasSuffix(outStr, "Transport endpoint is not connected") </span><span class="cov0" title="0">{
                        return true, err
                }</span> else<span class="cov1" title="1"> {
                        return false, err
                }</span>
        }
        //outStr := strings.TrimSpace(string(out))

        <span class="cov4" title="5">if strings.HasSuffix(outStr, "is a mountpoint") </span><span class="cov3" title="3">{
                p.Logger.Info(podUID+":"+"Path is a mountpoint",
                        zap.String("Pathname", pathname))
                return true, nil
        }</span> else<span class="cov2" title="2"> if strings.HasSuffix(outStr, "is not a mountpoint") </span><span class="cov1" title="1">{
                p.Logger.Info(podUID+":"+"Path is NOT a mountpoint",
                        zap.String("Pathname", pathname))
                return false, nil
        }</span> else<span class="cov1" title="1"> {
                p.Logger.Error(podUID+":"+"Cannot parse mountpoint result",
                        zap.String("Error", outStr))
                return false, fmt.Errorf("cannot parse mountpoint result: %s", outStr)
        }</span>
}

func (p *S3fsPlugin) unmountPath(mountPath string, delete bool) error <span class="cov9" title="33">{
        p.Logger.Info(podUID+":"+"Deleting mountpoint",
                zap.String("Mount path", mountPath))

        pathExist, err := pathExists(mountPath)
        if !pathExist </span><span class="cov9" title="31">{
                //If path does not exist
                if err == nil </span><span class="cov9" title="28">{
                        p.Logger.Info(podUID+":"+"Path does not exist",
                                zap.String("Mount path", mountPath))
                        return nil
                }</span> else<span class="cov3" title="3"> {
                        p.Logger.Error(podUID+":"+"Cannot stat directory",
                                zap.String("Mount path", mountPath), zap.Error(err))
                        return fmt.Errorf("cannot stat directory %s: %v", mountPath, err)
                }</span>
        }

        // directory exists
        <span class="cov2" title="2">isMount, checkMountErr := p.isMountpoint(mountPath)
        if isMount || checkMountErr != nil </span><span class="cov2" title="2">{
                p.Logger.Info(podUID+":"+"Calling unmount",
                        zap.String("Mount path", mountPath))
                err = unmount(mountPath, syscall.MNT_DETACH)
                if err != nil &amp;&amp; checkMountErr == nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+"Cannot unmount. Trying force unmount",
                                zap.String("Mount path", mountPath), zap.Error(err))
                        //Do force unmount
                        err = unmount(mountPath, syscall.MNT_FORCE)
                        if err != nil </span><span class="cov1" title="1">{
                                p.Logger.Error(podUID+":"+"Cannot force unmount",
                                        zap.String("Mount path", mountPath), zap.Error(err))
                                return fmt.Errorf("cannot force unmount %s: %v", mountPath, err)
                        }</span>
                }
        }

        <span class="cov1" title="1">if delete </span><span class="cov0" title="0">{
                p.Logger.Info(podUID+":"+"Deleting directory",
                        zap.String("Mount path", mountPath))
                err = removeAll(mountPath)
                if err != nil </span><span class="cov0" title="0">{
                        p.Logger.Error(podUID+":"+"Cannot remove",
                                zap.String("Mount path", mountPath), zap.Error(err))
                        return fmt.Errorf("cannot remove %s: %v", mountPath, err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (p *S3fsPlugin) createEmptyMountpoint(mountPath string) error <span class="cov8" title="23">{
        p.Logger.Info(podUID+":"+"Creating empty mountpoint",
                zap.String("mountPath", mountPath))

        err := p.unmountPath(mountPath, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // directory does not exist

        <span class="cov8" title="23">p.Logger.Info(podUID+":"+"Creating directory",
                zap.String("mountPath", mountPath))
        err = mkdirAll(mountPath, 0755)
        if err != nil </span><span class="cov1" title="1">{
                p.Logger.Error(podUID+":Cannot create directory",
                        zap.String("mountPath", mountPath), zap.Error(err))
                return fmt.Errorf("cannot create directory %s: %v", mountPath, err)
        }</span>

        // directory exists and unmounted
        <span class="cov8" title="22">p.Logger.Info(podUID+":"+"Creating tmpfs mountpoint",
                zap.String("mountPath", mountPath))
        err = mount("tmpfs", mountPath, "tmpfs", 0, "size=4k")
        if err != nil </span><span class="cov1" title="1">{
                p.Logger.Error(podUID+":Cannot create tmpfs mountpoint",
                        zap.String("mountPath", mountPath), zap.Error(err))
                return fmt.Errorf("cannot create tmpfs mountpoint %s: %v", mountPath, err)
        }</span>

        <span class="cov8" title="21">return nil</span>
}

// Init method is to initialize the flexvolume, it is a no op right now
func (p *S3fsPlugin) Init() interfaces.FlexVolumeResponse <span class="cov1" title="1">{
        p.Logger.Info(podUID + ":" + "S3fsPlugin-Init()-start")
        defer p.Logger.Info(podUID + ":" + "S3fsPlugin-Init()-end")

        return interfaces.FlexVolumeResponse{
                Status:       interfaces.StatusSuccess,
                Message:      "Plugin init successfully",
                Capabilities: interfaces.CapabilitiesResponse{Attach: false, FSGroup: false},
        }
}</span>

func (p *S3fsPlugin) checkBucket(endpoint, region, bucket string, creds *backend.ObjectStorageCredentials) error <span class="cov9" title="28">{
        p.Logger.Info(podUID+":"+"Checking if bucket exists",
                zap.String("bucket", bucket))
        sess := p.Backend.NewObjectStorageSession(endpoint, region, creds, p.Logger)
        return sess.CheckBucketAccess(bucket)
}</span>

func (p *S3fsPlugin) checkObjectPath(endpoint, region, bucket, objectpath string, creds *backend.ObjectStorageCredentials) (bool, error) <span class="cov4" title="4">{
        p.Logger.Info(podUID+":"+"Checking if object-path exists inside bucket",
                zap.String("bucket", bucket), zap.String("object-path", objectpath))
        sess := p.Backend.NewObjectStorageSession(endpoint, region, creds, p.Logger)
        return sess.CheckObjectPathExistence(bucket, objectpath)
}</span>

func (p *S3fsPlugin) createDirectoryIfNotExists(path string) error <span class="cov8" title="25">{
        p.Logger.Info(podUID+":"+"Checking if directory exists",
                zap.String("path", path))

        _, err := stat(path)
        if err == nil </span><span class="cov8" title="23">{
                p.Logger.Info(podUID+":"+"Directory exists",
                        zap.String("path", path))
        }</span> else<span class="cov2" title="2"> {
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        p.Logger.Info(podUID+":"+"Creating directory",
                                zap.String("path", path))
                        err = mkdirAll(path, 0755)
                        if err != nil </span><span class="cov1" title="1">{
                                p.Logger.Error(podUID+":"+"Cannot create directory",
                                        zap.Error(err))
                                return fmt.Errorf("cannot create directory: %v", err)
                        }</span>
                } else<span class="cov1" title="1"> {
                        p.Logger.Error(podUID+":"+"Cannot stat directory",
                                zap.Error(err))
                        return fmt.Errorf("cannot stat directory: %v", err)
                }</span>
        }
        <span class="cov8" title="23">return nil</span>
}

// Mount method allows to mount the volume/fileset to a given location for a pod
func (p *S3fsPlugin) mountInternal(mountRequest interfaces.FlexVolumeMountRequest) error <span class="cov10" title="42">{
        var options Options
        var apiKey, serviceInstanceId, accessKey, secretKey string
        var fInfo os.FileInfo
        var regionValue, endptValue, iamEndpoint string
        var fullBucketPath string

        err := parser.UnmarshalMap(&amp;mountRequest.Opts, &amp;options)
        if err != nil </span><span class="cov1" title="1">{
                p.Logger.Error(podUID+":"+"Cannot unmarshal driver options",
                        zap.Error(err))
                return fmt.Errorf("cannot unmarshal driver options: %v", err)
        }</span>

        // Support both endpoint and object-store-endpoint option
        <span class="cov9" title="41">if options.OSEndpoint != "" </span><span class="cov9" title="41">{
                endptValue = options.OSEndpoint
        }</span> else<span class="cov0" title="0"> {
                endptValue = options.Endpoint
        }</span>
        // Support both region and object-store-storage-class option
        <span class="cov9" title="41">if options.OSStorageClass != "" </span><span class="cov9" title="40">{
                regionValue = options.OSStorageClass
        }</span> else<span class="cov1" title="1"> if options.Region != "" </span><span class="cov0" title="0">{
                regionValue = options.Region
        }</span> else<span class="cov1" title="1"> {
                regionValue = "dummy-object-store-storageclass"
        }</span>

        <span class="cov9" title="41">if !(strings.HasPrefix(endptValue, "https://") || strings.HasPrefix(endptValue, "http://")) </span><span class="cov1" title="1">{
                p.Logger.Error(podUID+":"+
                        "Bad value for object-store-endpoint: scheme is missing."+
                        " Must be of the form http://&lt;hostname&gt; or https://&lt;hostname&gt;",
                        zap.String("object-store-endpoint", endptValue))
                return fmt.Errorf(podUID+":"+
                        "Bad value for object-store-endpoint \"%v\": scheme is missing."+
                        " Must be of the form http://&lt;hostname&gt; or https://&lt;hostname&gt;",
                        endptValue)
        }</span>

        //Check if value of s3fs-fuse-retry-count parameter can be converted to integer
        <span class="cov9" title="40">if options.S3FSFUSERetryCount != "" </span><span class="cov3" title="3">{
                retryCount, err := strconv.Atoi(options.S3FSFUSERetryCount)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                "Cannot convert value of s3fs-fuse-retry-count into integer",
                                zap.Error(err))
                        return fmt.Errorf("Cannot convert value of s3fs-fuse-retry-count into integer: %v", err)
                }</span>
                <span class="cov2" title="2">if retryCount &lt; 1 </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                " value of s3fs-fuse-retry-count should be &gt;= 1",
                                zap.Error(err))
                        return fmt.Errorf("value of s3fs-fuse-retry-count should be &gt;= 1")
                }</span>
        }

        //Check if value of stat-cache-expire-seconds parameter can be converted to integer
        <span class="cov9" title="38">if options.StatCacheExpireSeconds != "" </span><span class="cov3" title="3">{
                cacheExpireSeconds, err := strconv.Atoi(options.StatCacheExpireSeconds)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                " Cannot convert value of stat-cache-expire-seconds into integer",
                                zap.Error(err))
                        return fmt.Errorf("Cannot convert value of stat-cache-expire-seconds into integer: %v", err)
                }</span> else<span class="cov2" title="2"> if cacheExpireSeconds &lt; 0 </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                " value of stat-cache-expire-seconds should be &gt;= 0",
                                zap.Error(err))
                        return fmt.Errorf("value of stat-cache-expire-seconds should be &gt;= 0")
                }</span>
        }

        //Check if value of connect_timeout parameter can be converted to integer
        <span class="cov9" title="36">if options.ConnectTimeoutSeconds != "" </span><span class="cov2" title="2">{
                _, err := strconv.Atoi(options.ConnectTimeoutSeconds)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                "Cannot convert value of connect-timeout-seconds into integer",
                                zap.Error(err))
                        return fmt.Errorf("Cannot convert value of connect-timeout-seconds into integer: %v", err)
                }</span>
        }

        //Check if value of connect_timeout parameter can be converted to integer
        <span class="cov9" title="35">if options.ReadwriteTimeoutSeconds != "" </span><span class="cov2" title="2">{
                _, err := strconv.Atoi(options.ReadwriteTimeoutSeconds)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                "Cannot convert value of readwrite-timeout-seconds into integer",
                                zap.Error(err))
                        return fmt.Errorf("Cannot convert value of readwrite-timeout-seconds into integer: %v", err)
                }</span>
        }

        <span class="cov9" title="34">if options.APIKeyB64 != "" </span><span class="cov4" title="5">{
                apiKey, err = parser.DecodeBase64(options.APIKeyB64)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                " Cannot decode API key",
                                zap.Error(err))
                        return fmt.Errorf("cannot decode API key: %v", err)
                }</span>
                <span class="cov4" title="4">serviceInstanceId, err = parser.DecodeBase64(options.ServiceInstanceIDB64)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                " Cannot decode Service Instance ID",
                                zap.Error(err))
                        return fmt.Errorf("cannot decode Service Instance ID: %v", err)
                }</span>
        } else<span class="cov9" title="29"> {
                accessKey, err = parser.DecodeBase64(options.AccessKeyB64)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                " Cannot decode access key",
                                zap.Error(err))
                        return fmt.Errorf("cannot decode access key: %v", err)
                }</span>

                <span class="cov9" title="28">secretKey, err = parser.DecodeBase64(options.SecretKeyB64)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+
                                " Cannot decode secret key",
                                zap.Error(err))
                        return fmt.Errorf("cannot decode secret key: %v", err)
                }</span>
        }

        <span class="cov9" title="30">if apiKey != "" </span><span class="cov3" title="3">{
                if options.IAMEndpoint == "" </span><span class="cov1" title="1">{
                        iamEndpoint = defaultIAMEndPoint
                }</span> else<span class="cov2" title="2"> {
                        if !(strings.HasPrefix(options.IAMEndpoint, "https://") || strings.HasPrefix(options.IAMEndpoint, "http://")) </span><span class="cov1" title="1">{
                                p.Logger.Error(podUID+":"+
                                        " Bad value for iam-endpoint."+
                                        " Must be of the form https://&lt;hostname&gt; or http://&lt;hostname&gt;",
                                        zap.String("iam-endpoint", options.IAMEndpoint))
                                return fmt.Errorf(podUID+":"+
                                        " Bad value for iam-endpoint \"%v\":"+
                                        " Must be of the form https://&lt;hostname&gt; or http://&lt;hostname&gt;",
                                        options.IAMEndpoint)
                        }</span> else<span class="cov1" title="1"> {
                                iamEndpoint = options.IAMEndpoint
                        }</span>
                }
        }
        <span class="cov9" title="29">if options.CAbundleB64 != "" </span><span class="cov2" title="2">{
                CaBundleKey, err := parser.DecodeBase64(options.CAbundleB64)
                caFileName := "_ca.crt"
                if options.CosServiceIP != "" </span><span class="cov2" title="2">{
                        caFileName = options.CosServiceIP + "_ca.crt"
                }</span> else<span class="cov0" title="0"> {
                        pvName := filepath.Base(mountRequest.MountDir)
                        caFileName = pvName + "_ca.crt"
                }</span>
                <span class="cov2" title="2">caFile := path.Join(caPath, caFileName)
                p.Logger.Info(podUID+": CA CERT", zap.String("CA bundle file", caFile))
                err = writeFile(caFile, []byte(CaBundleKey), 0600)
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+" Cannot create ca crt file",
                                zap.Error(err))
                        return fmt.Errorf("cannot create ca crt file: %v", err)
                }</span>

                <span class="cov1" title="1">err = os.Setenv("CURL_CA_BUNDLE", caFile)
                if err != nil </span><span class="cov0" title="0">{
                        p.Logger.Error(podUID+":"+" Cannot set CURL_CA_BUNDLE env var",
                                zap.Error(err))
                        return fmt.Errorf("Cannot set CURL_CA_BUNDLE env var: %v", err)
                }</span>
                <span class="cov1" title="1">err = os.Setenv("AWS_CA_BUNDLE", caFile)
                if err != nil </span><span class="cov0" title="0">{
                        p.Logger.Error(podUID+":"+" Cannot set AWS_CA_BUNDLE env var",
                                zap.Error(err))
                        return fmt.Errorf("Cannot set AWS_CA_BUNDLE env var: %v", err)
                }</span>
        }
        // check that bucket exists before doing the mount
        <span class="cov9" title="28">err = p.checkBucket(endptValue, regionValue, options.Bucket,
                &amp;backend.ObjectStorageCredentials{
                        AccessKey:         accessKey,
                        SecretKey:         secretKey,
                        APIKey:            apiKey,
                        ServiceInstanceID: serviceInstanceId,
                        IAMEndpoint:       iamEndpoint})
        if err != nil </span><span class="cov1" title="1">{
                p.Logger.Error(podUID+":"+" Cannot access bucket",
                        zap.Error(err))
                return fmt.Errorf("cannot access bucket: %v", err)
        }</span>

        // check that object-path exists inside bucket before doing the mount
        <span class="cov8" title="27">if options.ObjectPath != "" </span><span class="cov4" title="4">{
                exist, err := p.checkObjectPath(endptValue, regionValue, options.Bucket, options.ObjectPath,
                        &amp;backend.ObjectStorageCredentials{
                                AccessKey:         accessKey,
                                SecretKey:         secretKey,
                                APIKey:            apiKey,
                                ServiceInstanceID: serviceInstanceId,
                                IAMEndpoint:       iamEndpoint})
                if err != nil </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+" Cannot access object-path inside bucket",
                                zap.String("bucket", options.Bucket), zap.String("object-path", options.ObjectPath), zap.Error(err))
                        return fmt.Errorf("cannot access object-path \"%s\" inside bucket %s: %v", options.ObjectPath, options.Bucket, err)
                }</span> else<span class="cov3" title="3"> if !exist </span><span class="cov1" title="1">{
                        p.Logger.Error(podUID+":"+" object-path not found inside bucket",
                                zap.String("bucket", options.Bucket), zap.String("object-path", options.ObjectPath))
                        return fmt.Errorf("object-path \"%s\" not found inside bucket %s", options.ObjectPath, options.Bucket)
                }</span>
        }

        // create target directory
        <span class="cov8" title="25">err = p.createDirectoryIfNotExists(mountRequest.MountDir)
        if err != nil </span><span class="cov2" title="2">{
                p.Logger.Error(podUID+":"+"Cannot create target directory",
                        zap.Error(err))
                return fmt.Errorf("cannot create target directory: %v", err)
        }</span>

        // mount data path
        <span class="cov8" title="23">mountPath := path.Join(dataRootPath, fmt.Sprintf("%x", sha256.Sum256([]byte(mountRequest.MountDir))))
        done := false
        err = p.createEmptyMountpoint(mountPath)
        if err != nil </span><span class="cov2" title="2">{
                p.Logger.Error(podUID+":"+" Cannot create mount point",
                        zap.Error(err))
                return fmt.Errorf("cannot create mount point: %v", err)
        }</span>

        <span class="cov8" title="21">defer func() </span><span class="cov8" title="21">{
                // try to delete cache upon error or panic
                if !done </span><span class="cov2" title="2">{
                        mounterr := p.unmountPath(mountPath, true)
                        if mounterr != nil </span><span class="cov0" title="0">{
                                p.Logger.Error(podUID+":"+"Error unmounting volume",
                                        zap.Error(mounterr))
                        }</span>
                }
        }()

        // create password file
        <span class="cov8" title="21">passwordFile := path.Join(mountPath, passwordFileName)
        if apiKey != "" </span><span class="cov2" title="2">{
                err = writeFile(passwordFile, []byte(":"+apiKey), 0600)
        }</span> else<span class="cov8" title="19"> {
                err = writeFile(passwordFile, []byte(accessKey+":"+secretKey), 0600)
        }</span>
        <span class="cov8" title="21">if err != nil </span><span class="cov1" title="1">{
                p.Logger.Error(podUID+":"+" Cannot create password file",
                        zap.Error(err))
                return fmt.Errorf("cannot create password file: %v", err)
        }</span>
        <span class="cov8" title="20">var tlsCipherSuite string
        if options.TLSCipherSuite != "" </span><span class="cov8" title="19">{
                tlsCipherSuite = options.TLSCipherSuite
        }</span> else<span class="cov1" title="1"> {
                tlsCipherSuite = defaultTLSCipherSuite
        }</span>

        <span class="cov8" title="20">if options.ObjectPath != "" </span><span class="cov2" title="2">{
                if strings.HasPrefix(options.ObjectPath, "/") </span><span class="cov1" title="1">{
                        fullBucketPath = options.Bucket + ":" + options.ObjectPath
                }</span> else<span class="cov1" title="1"> {
                        fullBucketPath = options.Bucket + ":/" + options.ObjectPath
                }</span>
        } else<span class="cov7" title="18"> {
                fullBucketPath = options.Bucket
        }</span>
        <span class="cov8" title="20">args := []string{fullBucketPath, mountRequest.MountDir,
                "-o", "multireq_max=" + strconv.Itoa(options.MultiReqMax),
                "-o", "cipher_suites=" + tlsCipherSuite,
                "-o", "use_path_request_style",
                "-o", "passwd_file=" + passwordFile,
                "-o", "url=" + endptValue,
                "-o", "endpoint=" + regionValue,
                "-o", "parallel_count=" + strconv.Itoa(options.ParallelCount),
                "-o", "multipart_size=" + strconv.Itoa(options.ChunkSizeMB),
                "-o", "dbglevel=" + options.DebugLevel,
                "-o", "max_stat_cache_size=" + strconv.Itoa(options.StatCacheSize),
                "-o", "allow_other",
                "-o", "max_background=1000",
                "-o", "mp_umask=002",
                "-o", "instance_name=" + mountRequest.MountDir,
        }

        //if options.FSGroup != "" {
        if _, ok := mountRequest.Opts["kubernetes.io/fsGroup"]; ok </span><span class="cov1" title="1">{
                args = append(args, "-o", "gid="+options.FSGroup)
                args = append(args, "-o", "uid="+options.FSGroup)
        }</span> else<span class="cov8" title="19"> if _, ok := mountRequest.Opts["kubernetes.io/mounterArgs.FsGroup"]; ok </span><span class="cov1" title="1">{
                args = append(args, "-o", "gid="+options.FSGroupNew)
                args = append(args, "-o", "uid="+options.FSGroupNew)
        }</span>

        // Check if AccessMode is ReadOnlyMany
        <span class="cov8" title="20">if options.AccessMode == "ReadOnlyMany" </span><span class="cov1" title="1">{
                args = append(args, "-o", "ro")
        }</span>

        //Number of retries for failed S3 transaction
        <span class="cov8" title="20">if options.S3FSFUSERetryCount != "" </span><span class="cov1" title="1">{
                args = append(args, "-o", "retries="+options.S3FSFUSERetryCount)
        }</span>

        <span class="cov8" title="20">if options.StatCacheExpireSeconds != "" </span><span class="cov1" title="1">{
                args = append(args, "-o", "stat_cache_expire="+options.StatCacheExpireSeconds)
        }</span>

        <span class="cov8" title="20">if options.CurlDebug </span><span class="cov1" title="1">{
                args = append(args, "-o", "curldbg")
        }</span>

        <span class="cov8" title="20">if options.AutoCache </span><span class="cov1" title="1">{
                args = append(args, "-o", "auto_cache")
        }</span>

        <span class="cov8" title="20">if options.KernelCache </span><span class="cov1" title="1">{
                args = append(args, "-o", "kernel_cache")
        }</span>

        <span class="cov8" title="20">if apiKey != "" </span><span class="cov2" title="2">{
                args = append(args, "-o", "ibm_iam_auth")
                args = append(args, "-o", "ibm_iam_endpoint="+iamEndpoint)
        }</span> else<span class="cov7" title="18"> {
                args = append(args, "-o", "default_acl=private")
        }</span>

        <span class="cov8" title="20">if options.ConnectTimeoutSeconds != "" </span><span class="cov1" title="1">{
                args = append(args, "-o", "connect_timeout="+options.ConnectTimeoutSeconds)
        }</span>

        <span class="cov8" title="20">if options.ReadwriteTimeoutSeconds != "" </span><span class="cov1" title="1">{
                args = append(args, "-o", "readwrite_timeout="+options.ReadwriteTimeoutSeconds)
        }</span>

        <span class="cov8" title="20">if options.UseXattr </span><span class="cov1" title="1">{
                args = append(args, "-o", "use_xattr")
        }</span>

        <span class="cov8" title="20">fInfo, err = os.Lstat(mountRequest.MountDir)
        if err == nil </span><span class="cov8" title="20">{
                p.Logger.Info(podUID+":"+"Target directory before-mount: ",
                        zap.String("mode:", fInfo.Mode().String()),
                        zap.Uint32("uid:", fInfo.Sys().(*syscall.Stat_t).Uid),
                        zap.Uint32("gid:", fInfo.Sys().(*syscall.Stat_t).Gid),
                        zap.String("path:", mountRequest.MountDir))
        }</span>

        <span class="cov8" title="20">p.Logger.Info(podUID+":"+"Running s3fs",
                zap.Reflect("args", args))

        output, err := command("s3fs", "--version").CombinedOutput()
        if err == nil </span><span class="cov8" title="19">{
                version := strings.Split(string(output), "\n")
                p.Logger.Info(podUID+":S3FS-Fuse info:", zap.String("Version", version[0]))
        }</span>
        <span class="cov8" title="20">p.Logger.Info(podUID+":S3FS-Driver info:", zap.String("Version", buildVersion))

        out, err := command("s3fs", args...).CombinedOutput()
        if err != nil </span><span class="cov1" title="1">{
                p.Logger.Error(podUID+":"+"Running s3fs",
                        zap.String("Error", string(out)))
                return fmt.Errorf("s3fs mount failed: %s", string(out))
        }</span>

        <span class="cov8" title="19">fInfo, err = os.Lstat(mountRequest.MountDir)
        if err == nil </span><span class="cov8" title="19">{
                p.Logger.Info(podUID+":"+"Target directory after-mount: ",
                        zap.String("mode:", fInfo.Mode().String()),
                        zap.Uint32("uid:", fInfo.Sys().(*syscall.Stat_t).Uid),
                        zap.Uint32("gid:", fInfo.Sys().(*syscall.Stat_t).Gid),
                        zap.String("path:", mountRequest.MountDir))
        }</span>

        <span class="cov8" title="19">done = true
        return nil</span>
}

// Mount method allows to mount the volume/fileset to a given location for a pod
func (p *S3fsPlugin) Mount(mountRequest interfaces.FlexVolumeMountRequest) interfaces.FlexVolumeResponse <span class="cov10" title="42">{
        p.Logger.Info(podUID + ":" + "S3fsPlugin-Mount()-start")
        defer p.Logger.Info(podUID + ":" + "S3fsPlugin-Mount()-end")

        err := p.mountInternal(mountRequest)
        if err != nil </span><span class="cov8" title="23">{
                p.Logger.Info(podUID+":"+"Error mounting volume",
                        zap.Reflect("err", err))

                return interfaces.FlexVolumeResponse{
                        Status:  interfaces.StatusFailure,
                        Message: fmt.Sprintf("Error mounting volume: %v", err),
                }
        }</span>

        <span class="cov8" title="19">p.Logger.Info(podUID+":"+"Successfully executed mount",
                zap.String("mountRequest.MountDir", mountRequest.MountDir))

        return interfaces.FlexVolumeResponse{
                Status:  interfaces.StatusSuccess,
                Message: fmt.Sprintf("Volume mounted successfully to %s", mountRequest.MountDir),
        }</span>
}

// Unmount methods unmounts the volume/ fileset from the pod
func (p *S3fsPlugin) Unmount(unmountRequest interfaces.FlexVolumeUnmountRequest) interfaces.FlexVolumeResponse <span class="cov2" title="2">{
        p.Logger.Info(podUID + ":" + "S3fsPlugin-Unmount()-start")
        defer p.Logger.Info(podUID + ":" + "S3fsPlugin-Unmount()-end")

        err := p.unmountInternal(unmountRequest)
        if err != nil </span><span class="cov1" title="1">{
                p.Logger.Info(podUID+":"+"Error unmounting volume",
                        zap.Reflect("err", err))

                return interfaces.FlexVolumeResponse{
                        Status:  interfaces.StatusFailure,
                        Message: fmt.Sprintf("Error unmounting volume: %v", err),
                }
        }</span>

        <span class="cov1" title="1">p.Logger.Info(podUID+":"+"Successfully executed unmount",
                zap.String("mountRequest.MountDir", unmountRequest.MountDir))

        return interfaces.FlexVolumeResponse{
                Status:  interfaces.StatusSuccess,
                Message: "Volume unmounted successfully",
        }</span>
}

// Unmount methods unmounts the volume/ fileset from the pod
func (p *S3fsPlugin) unmountInternal(unmountRequest interfaces.FlexVolumeUnmountRequest) error <span class="cov2" title="2">{
        err := p.unmountPath(unmountRequest.MountDir, false)
        if err != nil </span><span class="cov1" title="1">{
                p.Logger.Error(podUID+":"+"Cannot unmount s3fs mount point",
                        zap.String("Request", unmountRequest.MountDir),
                        zap.Error(err))
                return fmt.Errorf("cannot unmount s3fs mount point %s: %v", unmountRequest.MountDir, err)
        }</span>

        <span class="cov1" title="1">mountPath := path.Join(dataRootPath, fmt.Sprintf("%x", sha256.Sum256([]byte(unmountRequest.MountDir))))
        err = p.unmountPath(mountPath, true)
        if err != nil </span><span class="cov0" title="0">{
                p.Logger.Error(podUID+":"+"Cannot delete data  mount point",
                        zap.String("mountpath", mountPath), zap.Error(err))
                return fmt.Errorf("cannot delete data mount point %s: %v", mountPath, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package backend

import (
        "fmt"
        "github.com/IBM/ibm-cos-sdk-go/aws"
        "github.com/IBM/ibm-cos-sdk-go/aws/awserr"
        "github.com/IBM/ibm-cos-sdk-go/aws/credentials"
        "github.com/IBM/ibm-cos-sdk-go/aws/credentials/ibmiam"
        "github.com/IBM/ibm-cos-sdk-go/aws/session"
        "github.com/IBM/ibm-cos-sdk-go/service/s3"
        "go.uber.org/zap"
        "strings"
)

// ObjectStorageCredentials holds credentials for accessing an object storage service
type ObjectStorageCredentials struct {
        // AccessKey is the account identifier in AWS authentication
        AccessKey string
        // SecretKey is the "password" in AWS authentication
        SecretKey string
        // APIKey is the "password" in IBM IAM authentication
        APIKey string
        // ServiceInstanceID is the account identifier in IBM IAM authentication
        ServiceInstanceID string
        //IAMEndpoint ...
        IAMEndpoint string
}

// ObjectStorageSessionFactory is an interface of an object store session factory
type ObjectStorageSessionFactory interface {

        // NewObjectStorageBackend method creates a new object store session
        NewObjectStorageSession(endpoint, region string, creds *ObjectStorageCredentials, logger *zap.Logger) ObjectStorageSession
}

// ObjectStorageSession is an interface of an object store session
type ObjectStorageSession interface {

        // CheckBucketAccess method check that a bucket can be accessed
        CheckBucketAccess(bucket string) error

        // CheckObjectPathExistence method checks that object-path exists inside bucket
        CheckObjectPathExistence(bucket, objectpath string) (bool, error)

        // CreateBucket methods creates a new bucket
        CreateBucket(bucket string) (string, error)

        // DeleteBucket methods deletes a bucket (with all of its objects)
        DeleteBucket(bucket string) error
}

// COSSessionFactory represents a COS (S3) session factory
type COSSessionFactory struct{}

type s3API interface {
        HeadBucket(input *s3.HeadBucketInput) (*s3.HeadBucketOutput, error)
        CreateBucket(input *s3.CreateBucketInput) (*s3.CreateBucketOutput, error)
        ListObjects(input *s3.ListObjectsInput) (*s3.ListObjectsOutput, error)
        //ListObjectsV2(input *s3.ListObjectsV2Input) (*s3.ListObjectsV2Output, error)
        DeleteObject(input *s3.DeleteObjectInput) (*s3.DeleteObjectOutput, error)
        DeleteBucket(input *s3.DeleteBucketInput) (*s3.DeleteBucketOutput, error)
}

// COSSession represents a COS (S3) session
type COSSession struct {
        svc    s3API
        logger *zap.Logger
}

// NewObjectStorageSession method creates a new object store session
func (s *COSSessionFactory) NewObjectStorageSession(endpoint, region string, creds *ObjectStorageCredentials, logger *zap.Logger) ObjectStorageSession <span class="cov4" title="2">{
        var sdkCreds *credentials.Credentials
        if creds.APIKey != "" </span><span class="cov1" title="1">{
                sdkCreds = ibmiam.NewStaticCredentials(aws.NewConfig(), creds.IAMEndpoint+"/oidc/token", creds.APIKey, creds.ServiceInstanceID)
        }</span> else<span class="cov1" title="1"> {
                sdkCreds = credentials.NewStaticCredentials(creds.AccessKey, creds.SecretKey, "")
        }</span>
        <span class="cov4" title="2">sess, _ := session.NewSession(&amp;aws.Config{
                S3ForcePathStyle: aws.Bool(true),
                Endpoint:         aws.String(endpoint),
                Credentials:      sdkCreds,
                Region:           aws.String(region),
        })

        return &amp;COSSession{
                svc:    s3.New(sess),
                logger: logger,
        }</span>
}

// CheckBucketAccess method check that a bucket can be accessed
func (s *COSSession) CheckBucketAccess(bucket string) error <span class="cov4" title="2">{
        _, err := s.svc.HeadBucket(&amp;s3.HeadBucketInput{
                Bucket: aws.String(bucket),
        })

        return err
}</span>

// CheckObjectPathExistence method checks that object-path exists inside bucket
func (s *COSSession) CheckObjectPathExistence(bucket, objectpath string) (bool, error) <span class="cov7" title="3">{
        if strings.HasPrefix(objectpath, "/") </span><span class="cov7" title="3">{
                objectpath = strings.TrimPrefix(objectpath, "/")
        }</span>
        <span class="cov7" title="3">resp, err := s.svc.ListObjects(&amp;s3.ListObjectsInput{
                Bucket:  aws.String(bucket),
                MaxKeys: aws.Int64(1),
                Prefix:  aws.String(objectpath),
        })

        if err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("cannot list bucket '%s': %v", bucket, err)
        }</span>

        <span class="cov4" title="2">if len(resp.Contents) == 1 </span><span class="cov4" title="2">{
                object := *(resp.Contents[0].Key)
                if (object == objectpath) || (strings.TrimSuffix(object, "/") == objectpath) </span><span class="cov1" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov1" title="1">return false, nil</span>
}

// CreateBucket methods creates a new bucket
func (s *COSSession) CreateBucket(bucket string) (string, error) <span class="cov7" title="3">{
        _, err := s.svc.CreateBucket(&amp;s3.CreateBucketInput{
                Bucket: aws.String(bucket),
        })

        if err != nil </span><span class="cov4" title="2">{
                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "BucketAlreadyOwnedByYou" </span><span class="cov1" title="1">{
                        s.logger.Warn(fmt.Sprintf("bucket '%s' already exists", bucket))
                        return fmt.Sprintf("bucket '%s' already exists", bucket), nil
                }</span>
                <span class="cov1" title="1">return "", err</span>
        }

        <span class="cov1" title="1">return "", nil</span>
}

// DeleteBucket methods deletes a bucket (with all of its objects)
func (s *COSSession) DeleteBucket(bucket string) error <span class="cov10" title="5">{
        resp, err := s.svc.ListObjects(&amp;s3.ListObjectsInput{
                Bucket: aws.String(bucket),
        })

        if err != nil </span><span class="cov4" title="2">{
                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "NoSuchBucket" </span><span class="cov1" title="1">{
                        s.logger.Warn(fmt.Sprintf("bucket %s is already deleted", bucket))
                        return nil
                }</span>

                <span class="cov1" title="1">return fmt.Errorf("cannot list bucket '%s': %v", bucket, err)</span>
        }

        <span class="cov7" title="3">for _, key := range resp.Contents </span><span class="cov7" title="3">{
                _, err = s.svc.DeleteObject(&amp;s3.DeleteObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    key.Key,
                })

                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("cannot delete object %s/%s: %v", bucket, *key.Key, err)
                }</span>
        }

        <span class="cov4" title="2">_, err = s.svc.DeleteBucket(&amp;s3.DeleteBucketInput{
                Bucket: aws.String(bucket),
        })

        return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package config

import (
        "encoding/json"
        "fmt"
        "github.com/BurntSushi/toml"
        "github.com/IBM/ibmcloud-object-storage-plugin/utils/consts"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "os"
        "strconv"
        "strings"
)

// ClusterInfo ...
type ClusterInfo struct {
        ClusterID   string `json:"cluster_id"`
        ClusterName string `json:"cluster_name,omitempty"`
        DataCenter  string `json:"datacenter,omitempty"`
        CustomerID  string `json:"customer_id,omitempty"`
}

func getEnv(key string) string <span class="cov10" title="17">{
        return os.Getenv(strings.ToUpper(key))
}</span>

/* #nosec */
func setEnv(key string, value string) <span class="cov7" title="8">{
        os.Setenv(strings.ToUpper(key), value)
}</span>

// GetGoPath ...
func GetGoPath() string <span class="cov3" title="2">{
        if goPath := getEnv("GOPATH"); goPath != "" </span><span class="cov1" title="1">{
                return goPath
        }</span>
        <span class="cov1" title="1">return ""</span>
}

// ParseConfig ...
func ParseConfig(filePath string, conf interface{}, logger zap.Logger) <span class="cov3" title="2">{
        if _, err := toml.DecodeFile(filePath, conf); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error parsing config file", zap.Error(err))
        }</span>
}

// GetConfigString ...
func GetConfigString(envKey, defaultConf string) string <span class="cov3" title="2">{
        if val := getEnv(envKey); val != "" </span><span class="cov1" title="1">{
                return val
        }</span>
        <span class="cov1" title="1">return defaultConf</span>
}

// GetConfigInt ...
func GetConfigInt(envKey string, defaulfConf int, logger zap.Logger) int <span class="cov3" title="2">{
        if val := getEnv(envKey); val != "" </span><span class="cov1" title="1">{
                if envInt, err := strconv.Atoi(val); err == nil </span><span class="cov1" title="1">{
                        return envInt
                }</span>
                <span class="cov0" title="0">logger.Error("error parsing env val to int", zap.String("env", envKey))</span>
        }
        <span class="cov1" title="1">return defaulfConf</span>
}

// GetConfigBool ...
func GetConfigBool(envKey string, defaultConf bool, logger zap.Logger) bool <span class="cov3" title="2">{
        if val := getEnv(envKey); val != "" </span><span class="cov1" title="1">{
                if envBool, err := strconv.ParseBool(val); err == nil </span><span class="cov1" title="1">{
                        return envBool
                }</span>
                <span class="cov0" title="0">logger.Error("error parsing env val to bool", zap.String("env", envKey))</span>
        }
        <span class="cov1" title="1">return defaultConf</span>
}

// GetConfigStringList ...
func GetConfigStringList(envKey string, defaultConf string, logger zap.Logger) []string <span class="cov3" title="2">{
        // Assume env var is a list of strings separated by ','
        val := defaultConf

        if getEnv(envKey) != "" </span><span class="cov1" title="1">{
                val = getEnv(envKey)
        }</span>

        <span class="cov3" title="2">val = strings.Replace(val, " ", "", -1)
        return strings.Split(val, ",")</span>
}

// SetUpEvn ... Export the configmap (eg. cluster-info) to environment variables
func SetUpEvn(kubeclient kubernetes.Interface, logger *zap.Logger) error <span class="cov6" title="5">{
        logger.Info("Entry SetUpEvn")

        //Read cluster meta info
        err := LoadClusterInfoMap(kubeclient, logger)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov4" title="3">logger.Info("Exit SetUpEvn")
        return err</span>
}

//LoadClusterInfoMap ... Read cluster metadata from 'cluster-info' map and load into ENV
func LoadClusterInfoMap(kubeclient kubernetes.Interface, logger *zap.Logger) error <span class="cov6" title="5">{
        logger.Debug("Entry LoadClusterInfoMap")

        //check if the ENV variable already loaded
        clusterid := getEnv("cluster_id")
        if len(clusterid) &gt; 0 </span><span class="cov1" title="1">{
                logger.Info("Exit LoadClusterInfoMap, cluster_id already set", zap.String("cluster_id", clusterid))
                return nil
        }</span>

        // export cluster-info config map
        <span class="cov5" title="4">cmClusterInfo, err := kubeclient.Core().ConfigMaps(consts.KubeSystem).Get(consts.ClusterInfo, metav1.GetOptions{})
        if err != nil </span><span class="cov1" title="1">{
                err = fmt.Errorf("Unable to find the config map %s. Error: %v.Setting dummy values", consts.ClusterInfo, err)

                setEnv("CLUSTER_ID", "dummyClusterID")
                setEnv("CLUSTER_NAME", "dummyClusterName")
                setEnv("DATACENTER", "dummyDC")
                setEnv("CUSTOMER_ID", "dummyCustomerID")
                return nil
        }</span>

        <span class="cov4" title="3">logger.Debug("configmap details", zap.Reflect(consts.ClusterInfo, cmClusterInfo))
        clusterInfoData := cmClusterInfo.Data[consts.ClusterInfoData]
        clusteInfo := ClusterInfo{}
        err = json.Unmarshal([]byte(clusterInfoData), &amp;clusteInfo)
        if err != nil </span><span class="cov1" title="1">{
                err = fmt.Errorf("Error while parsing cluster-config %s. Error: %v", consts.ClusterInfo, err)
                return err
        }</span>

        <span class="cov3" title="2">logger.Info("Exporting cluster-config", zap.Reflect(consts.ClusterInfo, clusteInfo))
        if clusteInfo.ClusterID == "" </span><span class="cov1" title="1">{
                err = fmt.Errorf("cluster_id is not found in map %s", consts.ClusterInfo)
                return err
        }</span>
        <span class="cov1" title="1">setEnv("CLUSTER_ID", clusteInfo.ClusterID)
        setEnv("CLUSTER_NAME", clusteInfo.ClusterName)
        setEnv("DATACENTER", clusteInfo.DataCenter)
        setEnv("CUSTOMER_ID", clusteInfo.CustomerID)
        logger.Debug("Exit LoadClusterInfoMap")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package logger

import (
        "context"
        "errors"
        "github.com/IBM/ibmcloud-object-storage-plugin/utils/consts"
        uid "github.com/satori/go.uuid"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "os"
)

const (
        // PodName is the zap field key label for pod name
        PodName = "podName"
)

// ZapLogger is the global logger
var ZapLogger *zap.Logger

// GetZapLogger returns an instance of the logger, initializing a new logger
func GetZapLogger() (*zap.Logger, error) <span class="cov10" title="15">{
        if ZapLogger == nil </span><span class="cov10" title="15">{
                return NewZapLogger()
        }</span>
        <span class="cov0" title="0">return ZapLogger, nil</span>
}

// GetZapContextLogger Creates a new logger based from the global logger and adds values from the
// context as logging fields. If the context passed in is null then it
// returns the global logger
func GetZapContextLogger(ctx context.Context) (*zap.Logger, error) <span class="cov3" title="2">{
        var contextLogger *zap.Logger
        globalLogger, _ := GetZapLogger()
        if ctx != nil </span><span class="cov1" title="1">{
                contextLogger = addContextFields(ctx, globalLogger)
                return contextLogger, nil
        }</span>
        <span class="cov1" title="1">return globalLogger, nil</span>
}

// GetZapDefaultContextLogger Creates a new logger based from the global logger and adds RequestID from the
// context as logging field.
func GetZapDefaultContextLogger() (*zap.Logger, error) <span class="cov1" title="1">{
        var contextLogger *zap.Logger
        globalLogger, _ := GetZapLogger()
        contextLogger = addContextFields(generateContextWithRequestID(), globalLogger)
        return contextLogger, nil
}</span>

// GetZapContextLoggerFromLogger creates a new logger based from an existing logger and adds values from the
// context as logging fields. If the context passed in is null then it
// returns the global logger
func GetZapContextLoggerFromLogger(ctx context.Context, origLogger *zap.Logger) (*zap.Logger, error) <span class="cov5" title="4">{
        var contextLogger *zap.Logger
        if origLogger == nil </span><span class="cov3" title="2">{
                return origLogger, errors.New("a valid logger needs to be passed in")
        }</span>
        <span class="cov3" title="2">if ctx != nil </span><span class="cov1" title="1">{
                contextLogger = addContextFields(ctx, origLogger)
                return contextLogger, nil
        }</span>
        <span class="cov1" title="1">return origLogger, nil</span>
}

// Adds fields to an existing logger using values in the context
func addContextFields(ctx context.Context, origLogger *zap.Logger) *zap.Logger <span class="cov6" title="5">{
        if _, ok := ctx.Value(consts.TriggerKeyLabel).(string); ok </span><span class="cov1" title="1">{
                origLogger = origLogger.With(CreateZapTiggerKeyField(ctx))
        }</span>
        <span class="cov6" title="5">if _, ok := ctx.Value(consts.RequestIDLabel).(string); ok </span><span class="cov6" title="5">{
                origLogger = origLogger.With(CreateZapRequestIDField(ctx))
        }</span>
        <span class="cov6" title="5">return origLogger</span>
}

// NewZapLogger creates and returns a new global logger. It overwrites the
// existing global logger if that has been previously defined.
func NewZapLogger() (*zap.Logger, error) <span class="cov10" title="15">{
        productionConfig := zap.NewProductionConfig()
        productionConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        ZapLogger, _ := productionConfig.Build()
        return ZapLogger, nil
}</span>

// CreatePodNameLogger takes a zap logger and adds a pod name field
// NOTE: the logger returned is a different logger from the one passed in
func CreatePodNameLogger(logger *zap.Logger) (*zap.Logger, error) <span class="cov4" title="3">{
        if logger == nil </span><span class="cov1" title="1">{
                return nil, errors.New("logger passed in can not be null")
        }</span>
        <span class="cov3" title="2">podNameField := CreateZapPodNameKeyField()
        return logger.With(podNameField), nil</span>
}

// CreateZapRequestIDField Creates a zap logger field containing the request ID, convenience method for creating the
// field in cases where the ContextLogger can't be used and the field needs to be passed
// in as a parameter in the logging statements
func CreateZapRequestIDField(ctx context.Context) zapcore.Field <span class="cov7" title="8">{
        if ctx != nil </span><span class="cov7" title="7">{
                if requestID, ok := ctx.Value(consts.RequestIDLabel).(string); ok </span><span class="cov6" title="6">{
                        return zapcore.Field{Key: consts.RequestIDLabel, Type: zapcore.StringType, String: requestID}
                }</span>
        }
        <span class="cov3" title="2">return zapcore.Field{Key: consts.RequestIDLabel, Type: zapcore.StringType, String: ""}</span>
}

// CreateZapTiggerKeyField Creates a zap logger field containing the trigger key for a job, convenience method for creating the
// field in cases where the ContextLogger can't be used and the field needs to be passed
// in as a parameter in the logging statements
func CreateZapTiggerKeyField(ctx context.Context) zapcore.Field <span class="cov5" title="4">{
        if ctx != nil </span><span class="cov4" title="3">{
                if triggerKey, ok := ctx.Value(consts.TriggerKeyLabel).(string); ok </span><span class="cov3" title="2">{
                        return zapcore.Field{Key: consts.TriggerKeyLabel, Type: zapcore.StringType, String: triggerKey}
                }</span>
        }
        <span class="cov3" title="2">return zapcore.Field{Key: consts.TriggerKeyLabel, Type: zapcore.StringType, String: ""}</span>
}

// CreateZapPodNameKeyField Creates a zap logger field containing the pod name that the container is in,
// convenience method for creating the field so it can be passed
// in as a parameter in the logging statements
func CreateZapPodNameKeyField() zapcore.Field <span class="cov5" title="4">{
        pod := os.Getenv(consts.PodNameEnvVar)
        // if the pod name isn't set then the value will be empty
        return zapcore.Field{Key: PodName, Type: zapcore.StringType, String: pod}
}</span>

// Creates a context that contains a unique request ID
func generateContextWithRequestID() context.Context <span class="cov3" title="2">{
        requestID := uid.NewV4().String()
        return context.WithValue(context.Background(), consts.RequestIDLabel, requestID)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package parser

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
)

// DecodeBase64 decodes a base64 string
func DecodeBase64(encoded string) (string, error) <span class="cov5" title="2">{
        bytes, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov1" title="1">return string(bytes), nil</span>
}

// UnmarshalMap unmarshal a map[string]string to an interface (via JSON decoding)
func UnmarshalMap(m *map[string]string, v interface{}) error <span class="cov5" title="2">{
        jsonBytes, err := json.Marshal(*m)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot marshal map: %v", err)
        }</span>
        <span class="cov5" title="2">err = json.Unmarshal(jsonBytes, v)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot unmarshal '%s': %v", string(jsonBytes), err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// MarshalToMap converts an interface to map[string]string (via JSON encoding)
func MarshalToMap(v interface{}) (map[string]string, error) <span class="cov10" title="4">{
        var m map[string]interface{}

        jsonString, err := json.Marshal(v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("cannot marshal object: %v", err)
        }</span>
        <span class="cov8" title="3">err = json.Unmarshal([]byte(jsonString), &amp;m)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("cannot unmarshal '%s' to map: %v", jsonString, err)
        }</span>

        <span class="cov5" title="2">res := make(map[string]string)

        for k, v := range m </span><span class="cov5" title="2">{
                stringVal, ok := v.(string)
                if !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("cannot convert value to string: %v", v)
                }</span>
                <span class="cov1" title="1">res[k] = stringVal</span>
        }
        <span class="cov1" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package uuid

import (
        "crypto/rand"
        "fmt"
        "io"
)

// Generator generates UUID strings
type Generator interface {
        // New generates a random UUID according to RFC 4122
        New() (string, error)
}

// ReaderGenerator generates UUID strings using an IO reader
type ReaderGenerator struct {
        // Reader is the entropy source for the UUID generator
        Reader io.Reader
}

// NewCryptoGenerator returns new cryptographic UUID generator
func NewCryptoGenerator() *ReaderGenerator <span class="cov1" title="1">{
        return &amp;ReaderGenerator{Reader: rand.Reader}
}</span>

// New generates a random UUID according to RFC 4122
func (u *ReaderGenerator) New() (string, error) <span class="cov10" title="101">{
        uuid := make([]byte, 16)
        n, err := io.ReadFull(u.Reader, uuid)
        if n != len(uuid) || err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        // variant bits; see section 4.1.1
        <span class="cov9" title="100">uuid[8] = uuid[8]&amp;^0xc0 | 0x80
        // version 4 (pseudo-random); see section 4.1.3
        uuid[6] = uuid[6]&amp;^0xf0 | 0x40
        return fmt.Sprintf("%x-%x-%x-%x-%x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:]), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
