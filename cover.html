
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>fake-provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM/ibmcloud-object-storage-plugin/ibm-provider/provider/fake-provider/provider_grpc_fake.pb.go (0.0%)</option>
				
				<option value="file1">github.com/IBM/ibmcloud-object-storage-plugin/ibm-provider/provider/provider.pb.go (0.0%)</option>
				
				<option value="file2">github.com/IBM/ibmcloud-object-storage-plugin/ibm-provider/provider/provider_grpc.pb.go (0.0%)</option>
				
				<option value="file3">github.com/IBM/ibmcloud-object-storage-plugin/utils/backend/access_policy.go (92.3%)</option>
				
				<option value="file4">github.com/IBM/ibmcloud-object-storage-plugin/utils/backend/backend.go (90.0%)</option>
				
				<option value="file5">github.com/IBM/ibmcloud-object-storage-plugin/utils/backend/fake/fake_access_policy.go (0.0%)</option>
				
				<option value="file6">github.com/IBM/ibmcloud-object-storage-plugin/utils/backend/fake/fake_backend.go (0.0%)</option>
				
				<option value="file7">github.com/IBM/ibmcloud-object-storage-plugin/utils/config/config.go (95.2%)</option>
				
				<option value="file8">github.com/IBM/ibmcloud-object-storage-plugin/utils/grpc-client/fake-grpc/fake_grpc_client.go (0.0%)</option>
				
				<option value="file9">github.com/IBM/ibmcloud-object-storage-plugin/utils/grpc-client/grpc_client.go (62.5%)</option>
				
				<option value="file10">github.com/IBM/ibmcloud-object-storage-plugin/utils/logger/logger.go (97.8%)</option>
				
				<option value="file11">github.com/IBM/ibmcloud-object-storage-plugin/utils/parser/parser.go (97.1%)</option>
				
				<option value="file12">github.com/IBM/ibmcloud-object-storage-plugin/utils/uuid/uuid.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Kubernetes Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2023 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package fake_provider

import (
        "context"
        "errors"
        "github.com/IBM/ibmcloud-object-storage-plugin/ibm-provider/provider"
        "google.golang.org/grpc"
)

const (
        clusterTypeVpcG2   = "vpc-gen2"
        clusterTypeClassic = "cruiser"
        clusterTypeOther   = "other"
        testSvcEndpoint    = "10.10.10.10"
        emptySvcEndpoint   = ""
)

// FakeIBMProviderClientFactory implements provider.IBMProviderClientFactory
type FakeIBMProviderClientFactory struct {
        ClusterTypeVpcG2      bool
        ClusterTypeClassic    bool
        ClusterTypeOther      bool
        FailClusterType       bool
        FailClusterTypeErrMsg string
        FailSvcEndpoint       bool
        FailSvcEndpointErrMsg string
        TestSvcEndpoint       bool
        EmptySvcEndpoint      bool
}

var _ provider.IBMProviderClientFactory = (*FakeIBMProviderClientFactory)(nil)

// FakeIBMProviderClient implements provider.IBMProviderClient
type fakeIBMProviderClient struct {
        provider *FakeIBMProviderClientFactory
}

// NewIBMProviderClient method creates a new fake-grpc-client IBMProviderClient instance
func (pc *FakeIBMProviderClientFactory) NewIBMProviderClient(cc grpc.ClientConnInterface) provider.IBMProviderClient <span class="cov0" title="0">{
        return &amp;fakeIBMProviderClient{provider: pc}
}</span>

func (c *fakeIBMProviderClient) GetProviderType(
        ctx context.Context, in *provider.ProviderTypeRequest,
        opts ...grpc.CallOption,
) (*provider.ProviderTypeReply, error) <span class="cov0" title="0">{
        var reply provider.ProviderTypeReply
        if c.provider.ClusterTypeVpcG2 </span><span class="cov0" title="0">{
                reply = provider.ProviderTypeReply{Type: clusterTypeVpcG2}
        }</span> else<span class="cov0" title="0"> if c.provider.ClusterTypeClassic </span><span class="cov0" title="0">{
                reply = provider.ProviderTypeReply{Type: clusterTypeClassic}
        }</span> else<span class="cov0" title="0"> if c.provider.ClusterTypeOther </span><span class="cov0" title="0">{
                reply = provider.ProviderTypeReply{Type: clusterTypeOther}
        }</span> else<span class="cov0" title="0"> if c.provider.FailClusterType </span><span class="cov0" title="0">{
                return &amp;reply, errors.New(c.provider.FailClusterTypeErrMsg)
        }</span>
        <span class="cov0" title="0">out := &amp;reply
        return out, nil</span>
}

func (c *fakeIBMProviderClient) GetVPCSvcEndpoint(
        ctx context.Context, in *provider.VPCSvcEndpointRequest,
        opts ...grpc.CallOption,
) (*provider.VPCSvcEndpointReply, error) <span class="cov0" title="0">{
        var reply provider.VPCSvcEndpointReply
        if c.provider.ClusterTypeVpcG2 &amp;&amp; c.provider.TestSvcEndpoint </span><span class="cov0" title="0">{
                reply = provider.VPCSvcEndpointReply{Cse: testSvcEndpoint}
        }</span> else<span class="cov0" title="0"> if c.provider.ClusterTypeVpcG2 &amp;&amp; c.provider.EmptySvcEndpoint </span><span class="cov0" title="0">{
                reply = provider.VPCSvcEndpointReply{Cse: emptySvcEndpoint}
        }</span> else<span class="cov0" title="0"> if c.provider.ClusterTypeVpcG2 &amp;&amp; c.provider.FailSvcEndpoint </span><span class="cov0" title="0">{
                return &amp;reply, errors.New(c.provider.FailSvcEndpointErrMsg)
        }</span> else<span class="cov0" title="0"> {
                return &amp;reply, errors.New(c.provider.FailSvcEndpointErrMsg)
        }</span>
        <span class="cov0" title="0">out := &amp;reply
        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// *******************************************************************************
// * IBM Confidential
// * OCO Source Materials
// * IBM Cloud Container Service, 5737-D43
// * (C) Copyright IBM Corp. 2020 All Rights Reserved.
// * The source code for this program is not  published or otherwise divested of
// * its trade secrets, irrespective of what has been deposited with
// * the U.S. Copyright Office.
// ******************************************************************************/

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.24.0
//         protoc        v3.12.4
// source: provider/provider.proto

package provider

import (
        proto "github.com/golang/protobuf/proto"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// The provider type request
type ProviderTypeRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *ProviderTypeRequest) Reset() <span class="cov0" title="0">{
        *x = ProviderTypeRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_provider_provider_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ProviderTypeRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProviderTypeRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProviderTypeRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_provider_provider_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProviderTypeRequest.ProtoReflect.Descriptor instead.
func (*ProviderTypeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_provider_provider_proto_rawDescGZIP(), []int{0}
}</span>

func (x *ProviderTypeRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// The provider type reply
type ProviderTypeReply struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (x *ProviderTypeReply) Reset() <span class="cov0" title="0">{
        *x = ProviderTypeReply{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_provider_provider_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ProviderTypeReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProviderTypeReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProviderTypeReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_provider_provider_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProviderTypeReply.ProtoReflect.Descriptor instead.
func (*ProviderTypeReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_provider_provider_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ProviderTypeReply) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// The VPC cloud service endpoint request
type VPCSvcEndpointRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *VPCSvcEndpointRequest) Reset() <span class="cov0" title="0">{
        *x = VPCSvcEndpointRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_provider_provider_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *VPCSvcEndpointRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VPCSvcEndpointRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VPCSvcEndpointRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_provider_provider_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VPCSvcEndpointRequest.ProtoReflect.Descriptor instead.
func (*VPCSvcEndpointRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_provider_provider_proto_rawDescGZIP(), []int{2}
}</span>

func (x *VPCSvcEndpointRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// The VPC cloud service endpoint reply
type VPCSvcEndpointReply struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Cse string `protobuf:"bytes,1,opt,name=cse,proto3" json:"cse,omitempty"`
}

func (x *VPCSvcEndpointReply) Reset() <span class="cov0" title="0">{
        *x = VPCSvcEndpointReply{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_provider_provider_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *VPCSvcEndpointReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VPCSvcEndpointReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VPCSvcEndpointReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_provider_provider_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VPCSvcEndpointReply.ProtoReflect.Descriptor instead.
func (*VPCSvcEndpointReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_provider_provider_proto_rawDescGZIP(), []int{3}
}</span>

func (x *VPCSvcEndpointReply) GetCse() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cse
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_provider_provider_proto protoreflect.FileDescriptor

var file_provider_provider_proto_rawDesc = []byte{
        0x0a, 0x17, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x2f, 0x70, 0x72, 0x6f, 0x76, 0x69,
        0x64, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69,
        0x64, 0x65, 0x72, 0x22, 0x25, 0x0a, 0x13, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x54,
        0x79, 0x70, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x22, 0x27, 0x0a, 0x11, 0x50, 0x72,
        0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12,
        0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74,
        0x79, 0x70, 0x65, 0x22, 0x27, 0x0a, 0x15, 0x56, 0x50, 0x43, 0x53, 0x76, 0x63, 0x45, 0x6e, 0x64,
        0x70, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x22, 0x27, 0x0a, 0x13,
        0x56, 0x50, 0x43, 0x53, 0x76, 0x63, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x65,
        0x70, 0x6c, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x73, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x03, 0x63, 0x73, 0x65, 0x32, 0xad, 0x01, 0x0a, 0x0b, 0x49, 0x42, 0x4d, 0x50, 0x72, 0x6f,
        0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x4f, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x50, 0x72, 0x6f, 0x76,
        0x69, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1d, 0x2e, 0x70, 0x72, 0x6f, 0x76, 0x69,
        0x64, 0x65, 0x72, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64,
        0x65, 0x72, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x52,
        0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x4d, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x56, 0x50, 0x43,
        0x43, 0x53, 0x45, 0x12, 0x1f, 0x2e, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x2e, 0x56,
        0x50, 0x43, 0x53, 0x76, 0x63, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x2e,
        0x56, 0x50, 0x43, 0x53, 0x76, 0x63, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x65,
        0x70, 0x6c, 0x79, 0x22, 0x00, 0x42, 0x7d, 0x0a, 0x14, 0x69, 0x6f, 0x2e, 0x67, 0x72, 0x70, 0x63,
        0x2e, 0x69, 0x62, 0x6d, 0x2e, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x42, 0x0b, 0x49,
        0x42, 0x4d, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x50, 0x01, 0x5a, 0x56, 0x67, 0x69,
        0x74, 0x68, 0x75, 0x62, 0x2e, 0x69, 0x62, 0x6d, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61, 0x6c, 0x63,
        0x68, 0x65, 0x6d, 0x79, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x2f,
        0x61, 0x72, 0x6d, 0x61, 0x64, 0x61, 0x2d, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x2d, 0x73,
        0x33, 0x66, 0x73, 0x2d, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x2f, 0x63, 0x6d, 0x64, 0x2f, 0x69,
        0x62, 0x6d, 0x2d, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x2f, 0x70, 0x72, 0x6f, 0x76,
        0x69, 0x64, 0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_provider_provider_proto_rawDescOnce sync.Once
        file_provider_provider_proto_rawDescData = file_provider_provider_proto_rawDesc
)

func file_provider_provider_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_provider_provider_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_provider_provider_proto_rawDescData = protoimpl.X.CompressGZIP(file_provider_provider_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_provider_provider_proto_rawDescData</span>
}

var file_provider_provider_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_provider_provider_proto_goTypes = []interface{}{
        (*ProviderTypeRequest)(nil),   // 0: provider.ProviderTypeRequest
        (*ProviderTypeReply)(nil),     // 1: provider.ProviderTypeReply
        (*VPCSvcEndpointRequest)(nil), // 2: provider.VPCSvcEndpointRequest
        (*VPCSvcEndpointReply)(nil),   // 3: provider.VPCSvcEndpointReply
}
var file_provider_provider_proto_depIdxs = []int32{
        0, // 0: provider.IBMProvider.GetProviderType:input_type -&gt; provider.ProviderTypeRequest
        2, // 1: provider.IBMProvider.GetVPCSvcEndpoint:input_type -&gt; provider.VPCSvcEndpointRequest
        1, // 2: provider.IBMProvider.GetProviderType:output_type -&gt; provider.ProviderTypeReply
        3, // 3: provider.IBMProvider.GetVPCSvcEndpoint:output_type -&gt; provider.VPCSvcEndpointReply
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_provider_provider_proto_init() }</span>
func file_provider_provider_proto_init() <span class="cov0" title="0">{
        if File_provider_provider_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_provider_provider_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ProviderTypeRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_provider_provider_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ProviderTypeReply); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_provider_provider_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*VPCSvcEndpointRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_provider_provider_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*VPCSvcEndpointReply); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_provider_provider_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_provider_provider_proto_goTypes,
                DependencyIndexes: file_provider_provider_proto_depIdxs,
                MessageInfos:      file_provider_provider_proto_msgTypes,
        }.Build()
        File_provider_provider_proto = out.File
        file_provider_provider_proto_rawDesc = nil
        file_provider_provider_proto_goTypes = nil
        file_provider_provider_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go-grpc-client. DO NOT EDIT.

package provider

import (
        "context"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc-client package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

type IBMProviderClientFactory interface {

        // NewIBMProviderClient method creates a new NewIBMProviderClient instance
        NewIBMProviderClient(cc grpc.ClientConnInterface) IBMProviderClient
}

// IBMProviderClient is the client API for IBMProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IBMProviderClient interface {
        GetProviderType(ctx context.Context, in *ProviderTypeRequest, opts ...grpc.CallOption) (*ProviderTypeReply, error)
        GetVPCSvcEndpoint(ctx context.Context, in *VPCSvcEndpointRequest, opts ...grpc.CallOption) (*VPCSvcEndpointReply, error)
}

type IBMProviderClntFactory struct{}

type IBMProviderClnt struct {
        cc grpc.ClientConnInterface
}

// NewIBMProviderClient method creates a new NewIBMProviderClient instance
func (c *IBMProviderClntFactory) NewIBMProviderClient(cc grpc.ClientConnInterface) IBMProviderClient <span class="cov0" title="0">{
        return &amp;IBMProviderClnt{cc}
}</span>

func (c *IBMProviderClnt) GetProviderType(
        ctx context.Context, in *ProviderTypeRequest,
        opts ...grpc.CallOption,
) (*ProviderTypeReply, error) <span class="cov0" title="0">{
        out := new(ProviderTypeReply)
        err := c.cc.Invoke(ctx, "/provider.IBMProvider/GetProviderType", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *IBMProviderClnt) GetVPCSvcEndpoint(
        ctx context.Context, in *VPCSvcEndpointRequest,
        opts ...grpc.CallOption,
) (*VPCSvcEndpointReply, error) <span class="cov0" title="0">{
        out := new(VPCSvcEndpointReply)
        err := c.cc.Invoke(ctx, "/provider.IBMProvider/GetVPCSvcEndpoint", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// IBMProviderServer is the server API for IBMProvider service.
// All implementations must embed UnimplementedIBMProviderServer
// for forward compatibility
type IBMProviderServer interface {
        GetProviderType(context.Context, *ProviderTypeRequest) (*ProviderTypeReply, error)
        GetVPCSvcEndpoint(context.Context, *VPCSvcEndpointRequest) (*VPCSvcEndpointReply, error)
        mustEmbedUnimplementedIBMProviderServer()
}

// UnimplementedIBMProviderServer must be embedded to have forward compatible implementations.
type UnimplementedIBMProviderServer struct {
}

func (*UnimplementedIBMProviderServer) GetProviderType(
        context.Context, *ProviderTypeRequest,
) (*ProviderTypeReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetProviderType not implemented")
}</span>
func (*UnimplementedIBMProviderServer) GetVPCSvcEndpoint(
        context.Context, *VPCSvcEndpointRequest,
) (*VPCSvcEndpointReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVPCSvcEndpoint not implemented")
}</span>
func (*UnimplementedIBMProviderServer) mustEmbedUnimplementedIBMProviderServer() {<span class="cov0" title="0">}</span>

func RegisterIBMProviderServer(s *grpc.Server, srv IBMProviderServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_IBMProvider_serviceDesc, srv)
}</span>

func _IBMProvider_GetProviderType_Handler(
        srv interface{}, ctx context.Context,
        dec func(interface{}) error,
        interceptor grpc.UnaryServerInterceptor,
) (interface{}, error) <span class="cov0" title="0">{
        in := new(ProviderTypeRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(IBMProviderServer).GetProviderType(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/provider.IBMProvider/GetProviderType",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(IBMProviderServer).GetProviderType(ctx, req.(*ProviderTypeRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _IBMProvider_GetVPCSvcEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(VPCSvcEndpointRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(IBMProviderServer).GetVPCSvcEndpoint(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/provider.IBMProvider/GetVPCSvcEndpoint",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(IBMProviderServer).GetVPCSvcEndpoint(ctx, req.(*VPCSvcEndpointRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _IBMProvider_serviceDesc = grpc.ServiceDesc{
        ServiceName: "provider.IBMProvider",
        HandlerType: (*IBMProviderServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetProviderType",
                        Handler:    _IBMProvider_GetProviderType_Handler,
                },
                {
                        MethodName: "GetVPCSvcEndpoint",
                        Handler:    _IBMProvider_GetVPCSvcEndpoint_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "provider/provider.proto",
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Kubernetes Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2023 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package backend

import (
        "fmt"
        "github.com/IBM/go-sdk-core/v3/core"
        rc "github.com/IBM/ibm-cos-sdk-go-config/resourceconfigurationv1"
        "strconv"
        "strings"
)

const ResourceConfigEPDirect = "https://config.direct.cloud-object-storage.cloud.ibm.com/v1"
const ResourceConfigEPPrivate = "https://config.private.cloud-object-storage.cloud.ibm.com/v1"
const IAMEPForVPC = "https://private.iam.cloud.ibm.com/identity/token"
const Private = "private"

type AccessPolicyFactory interface {
        NewAccessPolicy() AccessPolicy
}

type AccessPolicy interface {
        UpdateAccessPolicy(allowedIps, apiKey, bucketName string, rcc ResourceConfigurationV1) error
        UpdateQuotaLimit(quota int64, apiKey, bucketName, osEndpoint, iamEndpoint string, rcc ResourceConfigurationV1) error
}

type UpdateAPFactory struct{}

type ResourceConfigurationV1 interface {
        // UpdateBucketConfig updates the bucket access policy configuration with given ips
        UpdateBucketConfig(*rc.ResourceConfigurationV1, *rc.UpdateBucketConfigOptions) (*core.DetailedResponse, error)
}

type UpdateAPObj struct {
        rcv1 ResourceConfigurationV1
}

func (uc *UpdateAPObj) UpdateBucketConfig(service *rc.ResourceConfigurationV1, options *rc.UpdateBucketConfigOptions) (res *core.DetailedResponse, err error) <span class="cov0" title="0">{
        return service.UpdateBucketConfig(options)
}</span>

func (c *UpdateAPFactory) NewAccessPolicy() AccessPolicy <span class="cov1" title="1">{

        return &amp;UpdateAPObj{}
}</span>

//var rcc ResourceConfigurationV1 = &amp;UpdateAPObj{}

// UpdateAccessPolicy updates the bucket access policy configuration with given ips
func (c *UpdateAPObj) UpdateAccessPolicy(allowedIps, apiKey, bucketName string, rcc ResourceConfigurationV1) error <span class="cov10" title="2">{

        allowedIPs := strings.Split(allowedIps, ",")
        for i := range allowedIPs </span><span class="cov10" title="2">{
                allowedIPs[i] = strings.TrimSpace(allowedIPs[i])
        }</span>

        <span class="cov10" title="2">authenticator := &amp;core.IamAuthenticator{
                ApiKey: apiKey,
                URL:    IAMEPForVPC,
        }

        service, _ := rc.NewResourceConfigurationV1(&amp;rc.ResourceConfigurationV1Options{
                Authenticator: authenticator,
                URL:           ResourceConfigEPDirect,
        })

        updateConfigOptions := &amp;rc.UpdateBucketConfigOptions{
                Bucket: core.StringPtr(bucketName),
                Firewall: &amp;rc.Firewall{
                        AllowedIp: allowedIPs,
                },
        }

        response, err := rcc.UpdateBucketConfig(service, updateConfigOptions)
        if response != nil </span><span class="cov1" title="1">{
                fmt.Println("UpdateAccessPolicy Response ", strconv.Itoa(response.StatusCode))
        }</span>
        <span class="cov10" title="2">return err</span>
}

// UpdateQuotaLimit updates the bucket quota limits
func (c *UpdateAPObj) UpdateQuotaLimit(quota int64, apiKey, bucketName, osEndpoint, iamEndpoint string, rcc ResourceConfigurationV1) error <span class="cov10" title="2">{

        ConfigEP := ""
        IAMEP := iamEndpoint + "/identity/token"

        if strings.Contains(osEndpoint, Private) </span><span class="cov0" title="0">{
                ConfigEP = ResourceConfigEPPrivate
        }</span> else<span class="cov10" title="2"> {
                ConfigEP = ResourceConfigEPDirect
        }</span>

        <span class="cov10" title="2">fmt.Println("ConfigEP used: ", ConfigEP)
        fmt.Println("IAMEndpoint used: ", IAMEP)

        authenticator := &amp;core.IamAuthenticator{
                ApiKey: apiKey,
                URL:    IAMEP,
        }

        service, _ := rc.NewResourceConfigurationV1(&amp;rc.ResourceConfigurationV1Options{
                Authenticator: authenticator,
                URL:           ConfigEP,
        })

        updateConfigOptions := &amp;rc.UpdateBucketConfigOptions{
                Bucket:    core.StringPtr(bucketName),
                HardQuota: core.Int64Ptr(quota),
        }

        response, err := rcc.UpdateBucketConfig(service, updateConfigOptions)
        if response != nil </span><span class="cov1" title="1">{
                fmt.Println("UpdateQuotaLimit Response ", strconv.Itoa(response.StatusCode))
        }</span>
        <span class="cov10" title="2">return err</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package backend

import (
        "fmt"
        "strings"

        "github.com/IBM/ibm-cos-sdk-go/aws"
        "github.com/IBM/ibm-cos-sdk-go/aws/awserr"
        "github.com/IBM/ibm-cos-sdk-go/aws/credentials"
        "github.com/IBM/ibm-cos-sdk-go/aws/credentials/ibmiam"
        "github.com/IBM/ibm-cos-sdk-go/aws/session"
        "github.com/IBM/ibm-cos-sdk-go/service/s3"
        "go.uber.org/zap"
)

// ObjectStorageCredentials holds credentials for accessing an object storage service
type ObjectStorageCredentials struct {
        // AccessKey is the account identifier in AWS authentication
        AccessKey string
        // SecretKey is the "password" in AWS authentication
        SecretKey string
        // APIKey is the "password" in IBM IAM authentication
        APIKey string
        // ServiceInstanceID is the account identifier in IBM IAM authentication
        ServiceInstanceID string
        //IAMEndpoint ...
        IAMEndpoint string
}

// ObjectStorageSessionFactory is an interface of an object store session factory
type ObjectStorageSessionFactory interface {

        // NewObjectStorageBackend method creates a new object store session
        NewObjectStorageSession(endpoint, region string, creds *ObjectStorageCredentials, logger *zap.Logger) ObjectStorageSession
}

// ObjectStorageSession is an interface of an object store session
type ObjectStorageSession interface {

        // CheckBucketAccess method check that a bucket can be accessed
        CheckBucketAccess(bucket string) error

        // CheckObjectPathExistence method checks that object-path exists inside bucket
        CheckObjectPathExistence(bucket, objectpath string) (bool, error)

        // CreateBucket methods creates a new bucket
        CreateBucket(bucket, locationConstraint string, kpRootKeyCrn string) (string, error)

        // DeleteBucket methods deletes a bucket (with all of its objects)
        DeleteBucket(bucket string) error

        // SetBucketVersioning sets the versioning state of a bucket
        SetBucketVersioning(bucket string, enabled bool) (string, error)
}

// COSSessionFactory represents a COS (S3) session factory
type COSSessionFactory struct{}

type s3API interface {
        HeadBucket(input *s3.HeadBucketInput) (*s3.HeadBucketOutput, error)
        CreateBucket(input *s3.CreateBucketInput) (*s3.CreateBucketOutput, error)
        ListObjects(input *s3.ListObjectsInput) (*s3.ListObjectsOutput, error)
        //ListObjectsV2(input *s3.ListObjectsV2Input) (*s3.ListObjectsV2Output, error)
        DeleteObject(input *s3.DeleteObjectInput) (*s3.DeleteObjectOutput, error)
        DeleteBucket(input *s3.DeleteBucketInput) (*s3.DeleteBucketOutput, error)
        PutBucketVersioning(input *s3.PutBucketVersioningInput) (*s3.PutBucketVersioningOutput, error)
}

// COSSession represents a COS (S3) session
type COSSession struct {
        svc    s3API
        logger *zap.Logger
}

const (
        KPEncryptionAlgorithm = "AES256" // https://github.com/IBM/ibm-cos-sdk-go/blob/master/service/s3/api.go#L8509-L8511
)

// NewObjectStorageSession method creates a new object store session
func (s *COSSessionFactory) NewObjectStorageSession(endpoint, region string, creds *ObjectStorageCredentials, logger *zap.Logger) ObjectStorageSession <span class="cov4" title="2">{
        var sdkCreds *credentials.Credentials
        if creds.APIKey != "" </span><span class="cov1" title="1">{
                sdkCreds = ibmiam.NewStaticCredentials(aws.NewConfig(), creds.IAMEndpoint+"/identity/token", creds.APIKey, creds.ServiceInstanceID)
        }</span> else<span class="cov1" title="1"> {
                sdkCreds = credentials.NewStaticCredentials(creds.AccessKey, creds.SecretKey, "")
        }</span>
        <span class="cov4" title="2">sess, _ := session.NewSession(&amp;aws.Config{
                S3ForcePathStyle: aws.Bool(true),
                Endpoint:         aws.String(endpoint),
                Credentials:      sdkCreds,
                Region:           aws.String(region),
        })

        return &amp;COSSession{
                svc:    s3.New(sess),
                logger: logger,
        }</span>
}

// CheckBucketAccess method check that a bucket can be accessed
func (s *COSSession) CheckBucketAccess(bucket string) error <span class="cov4" title="2">{
        _, err := s.svc.HeadBucket(&amp;s3.HeadBucketInput{
                Bucket: aws.String(bucket),
        })
        if err != nil </span><span class="cov1" title="1">{
                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "RequestError" &amp;&amp; strings.Contains(err.Error(), "Credential=") </span><span class="cov0" title="0">{
                        s.logger.Warn(fmt.Sprintf("Check your secret access key for bucket %s", bucket))
                        return fmt.Errorf("AccessKey/SecretKey is wrong")
                }</span>
        }

        <span class="cov4" title="2">return err</span>
}

// CheckObjectPathExistence method checks that object-path exists inside bucket
func (s *COSSession) CheckObjectPathExistence(bucket, objectpath string) (bool, error) <span class="cov8" title="4">{
        if strings.HasPrefix(objectpath, "/") </span><span class="cov8" title="4">{
                objectpath = strings.TrimPrefix(objectpath, "/")
        }</span>
        <span class="cov8" title="4">if !strings.HasSuffix(objectpath, "/") </span><span class="cov8" title="4">{
                objectpath = objectpath + "/"
        }</span>

        <span class="cov8" title="4">resp, err := s.svc.ListObjects(&amp;s3.ListObjectsInput{
                Bucket:  aws.String(bucket),
                MaxKeys: aws.Int64(1),
                Prefix:  aws.String(objectpath),
        })

        if err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("cannot list bucket '%s': %v", bucket, err)
        }</span>

        <span class="cov7" title="3">if len(resp.Contents) == 1 </span><span class="cov7" title="3">{
                object := *(resp.Contents[0].Key)
                if (object == objectpath) || (strings.TrimSuffix(object, "/") == objectpath) </span><span class="cov1" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov4" title="2">return false, nil</span>
}

// CreateBucket methods creates a new bucket
func (s *COSSession) CreateBucket(bucket, locationConstraint string, kpRootKeyCrn string) (string, error) <span class="cov7" title="3">{
        var err error
        if kpRootKeyCrn != "" </span><span class="cov7" title="3">{
                _, err = s.svc.CreateBucket(&amp;s3.CreateBucketInput{
                        Bucket: aws.String(bucket),
                        CreateBucketConfiguration: &amp;s3.CreateBucketConfiguration{
                                LocationConstraint: aws.String(locationConstraint),
                        },
                        IBMSSEKPCustomerRootKeyCrn:  aws.String(kpRootKeyCrn),
                        IBMSSEKPEncryptionAlgorithm: aws.String(KPEncryptionAlgorithm),
                })
        }</span> else<span class="cov0" title="0"> {
                _, err = s.svc.CreateBucket(&amp;s3.CreateBucketInput{
                        Bucket: aws.String(bucket),
                        CreateBucketConfiguration: &amp;s3.CreateBucketConfiguration{
                                LocationConstraint: aws.String(locationConstraint),
                        },
                })
        }</span>

        <span class="cov7" title="3">if err != nil </span><span class="cov4" title="2">{
                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "BucketAlreadyOwnedByYou" </span><span class="cov1" title="1">{
                        s.logger.Warn(fmt.Sprintf("bucket '%s' already exists", bucket))
                        return fmt.Sprintf("bucket '%s' already exists", bucket), nil
                }</span> else<span class="cov1" title="1"> if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "RequestError" &amp;&amp; strings.Contains(err.Error(), "Credential=") </span><span class="cov0" title="0">{
                        s.logger.Warn(fmt.Sprintf("Check your secret access key for bucket %s", bucket))
                        return fmt.Sprintf("Check your secret access key for bucket %s", bucket), fmt.Errorf("AccessKey/SecretKey is wrong")
                }</span>
                <span class="cov1" title="1">return "", err</span>
        }
        <span class="cov1" title="1">return "", nil</span>
}

// DeleteBucket methods deletes a bucket (with all of its objects)
func (s *COSSession) DeleteBucket(bucket string) error <span class="cov10" title="5">{
        resp, err := s.svc.ListObjects(&amp;s3.ListObjectsInput{
                Bucket: aws.String(bucket),
        })

        if err != nil </span><span class="cov4" title="2">{
                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "NoSuchBucket" </span><span class="cov1" title="1">{
                        s.logger.Warn(fmt.Sprintf("bucket %s is already deleted", bucket))
                        return nil
                }</span>

                <span class="cov1" title="1">return fmt.Errorf("cannot list bucket '%s': %v", bucket, err)</span>
        }

        <span class="cov7" title="3">for _, key := range resp.Contents </span><span class="cov7" title="3">{
                _, err = s.svc.DeleteObject(&amp;s3.DeleteObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    key.Key,
                })

                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("cannot delete object %s/%s: %v", bucket, *key.Key, err)
                }</span>
        }

        <span class="cov4" title="2">_, err = s.svc.DeleteBucket(&amp;s3.DeleteBucketInput{
                Bucket: aws.String(bucket),
        })
        return err</span>
}

func (s *COSSession) SetBucketVersioning(bucket string, enabled bool) (string, error) <span class="cov7" title="3">{
        var status string

        // Set the versioning status based on whether it's enabled or suspended.
        if enabled </span><span class="cov4" title="2">{
                status = s3.BucketVersioningStatusEnabled
        }</span> else<span class="cov1" title="1"> {
                status = s3.BucketVersioningStatusSuspended
        }</span>

        // Make the API call to set the versioning status of the bucket.
        <span class="cov7" title="3">out, err := s.svc.PutBucketVersioning(&amp;s3.PutBucketVersioningInput{
                Bucket: aws.String(bucket),
                VersioningConfiguration: &amp;s3.VersioningConfiguration{
                        Status: aws.String(status),
                },
        })

        // Check for errors from the AWS SDK call
        if err != nil </span><span class="cov1" title="1">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        s.logger.Error("Versioning operation failed",
                                zap.String("bucket", bucket),
                                zap.String("status", status),
                                zap.Error(aerr))
                }</span>
                <span class="cov1" title="1">return "", fmt.Errorf("failed to set versioning status to %s: %w", status, err)</span>
        }

        // Log the output for debugging or confirmation
        <span class="cov4" title="2">s.logger.Info("Bucket versioning response",
                zap.String("bucket", bucket),
                zap.String("status", status),
                zap.Any("response", out))

        // Return the status and nil error if successful
        return status, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Kubernetes Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2023 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package fake

import (
        "errors"
        "github.com/IBM/ibmcloud-object-storage-plugin/utils/backend"
)

// FakeAccessPolicyFactory implements backend.AccessPolicyFactory
type FakeAccessPolicyFactory struct {
        //FailUpdateAccessPolicy ...
        FailUpdateAccessPolicy bool
        //FailUpdateAccessPolicyErrMsg with specific error msg...
        FailUpdateAccessPolicyErrMsg string
        //PassUpdateAccessPolicy ...
        PassUpdateAccessPolicy bool
        //FailUpdateAccessPolicy ...
        FailUpdateQuotaLimit bool
        //FailUpdateAccessPolicyErrMsg with specific error msg...
        FailUpdateQuotaLimitErrMsg string
        //PassUpdateAccessPolicy ...
        PassUpdateQuotaLimit bool
}

var _ backend.AccessPolicyFactory = (*FakeAccessPolicyFactory)(nil)

// fakeAccessPolicy implements backend.AccessPolicy
type fakeAccessPolicy struct {
        rcv1 *FakeAccessPolicyFactory
}

// NewAccessPolicy method creates a new fakeAccessPolicy session
func (c *FakeAccessPolicyFactory) NewAccessPolicy() backend.AccessPolicy <span class="cov0" title="0">{
        return &amp;fakeAccessPolicy{
                rcv1: c,
        }
}</span>

// UpdateAccessPolicy method creates a fake updateBucketConfig call
func (c *fakeAccessPolicy) UpdateAccessPolicy(allowedIps, apiKey, bucketName string, rcc backend.ResourceConfigurationV1) error <span class="cov0" title="0">{
        if c.rcv1.FailUpdateAccessPolicy </span><span class="cov0" title="0">{
                return errors.New(c.rcv1.FailUpdateAccessPolicyErrMsg)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateQuotaLimit method creates a fake updateQuotaLimit call
func (c *fakeAccessPolicy) UpdateQuotaLimit(quota int64, apiKey, bucketName, osEndpoint, iamEndpoint string, rcc backend.ResourceConfigurationV1) error <span class="cov0" title="0">{
        if c.rcv1.FailUpdateAccessPolicy </span><span class="cov0" title="0">{
                return errors.New(c.rcv1.FailUpdateAccessPolicyErrMsg)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package fake

import (
        "errors"

        "github.com/IBM/ibmcloud-object-storage-plugin/utils/backend"
        "go.uber.org/zap"
)

// ObjectStorageSessionFactory is a factory for mocked object storage sessions
type ObjectStorageSessionFactory struct {
        //FailCheckBucketAccess ...
        FailCheckBucketAccess bool
        //FailCreateBucket ...
        FailCreateBucket bool
        //FailCreateBucket with specific error msg...
        FailCreateBucketErrMsg string
        //FailDeleteBucket ...
        FailDeleteBucket bool
        //CheckObjectPathExistenceError ...
        CheckObjectPathExistenceError bool
        //CheckObjectPathExistencePathNotFound ...
        CheckObjectPathExistencePathNotFound bool
        //FailSetBucketVersioning
        FailSetBucketVersioning bool

        // LastEndpoint holds the endpoint of the last created session
        LastEndpoint string
        // LastRegion holds the region of the last created session
        LastRegion string
        // LastCredentials holds the credentials of the last created session
        LastCredentials *backend.ObjectStorageCredentials
        // LastCheckedBucket stores the name of the last bucket that was checked
        LastCheckedBucket string
        // LastCreatedBucket stores the name of the last bucket that was created
        LastCreatedBucket string
        // LastDeletedBucket stores the name of the last bucket that was deleted
        LastDeletedBucket string
        //LastUpdatedBucket
        LastUpdatedBucket string
}

type fakeObjectStorageSession struct {
        factory *ObjectStorageSessionFactory
}

// NewObjectStorageSession method creates a new fake object store session
func (f *ObjectStorageSessionFactory) NewObjectStorageSession(endpoint, region string, creds *backend.ObjectStorageCredentials, logger *zap.Logger) backend.ObjectStorageSession <span class="cov0" title="0">{
        f.LastEndpoint = endpoint
        f.LastRegion = region
        f.LastCredentials = creds
        return &amp;fakeObjectStorageSession{
                factory: f,
        }
}</span>

// ResetStats clears the details about previous sessions
func (f *ObjectStorageSessionFactory) ResetStats() <span class="cov0" title="0">{
        f.LastEndpoint = ""
        f.LastRegion = ""
        f.LastCredentials = &amp;backend.ObjectStorageCredentials{}
        f.LastCheckedBucket = ""
        f.LastCreatedBucket = ""
        f.LastDeletedBucket = ""
        f.LastUpdatedBucket = ""
}</span>

func (s *fakeObjectStorageSession) CheckBucketAccess(bucket string) error <span class="cov0" title="0">{
        s.factory.LastCheckedBucket = bucket
        if s.factory.FailCheckBucketAccess </span><span class="cov0" title="0">{
                return errors.New("")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *fakeObjectStorageSession) CheckObjectPathExistence(bucket, objectpath string) (bool, error) <span class="cov0" title="0">{
        if s.factory.CheckObjectPathExistenceError </span><span class="cov0" title="0">{
                return false, errors.New("")
        }</span> else<span class="cov0" title="0"> if s.factory.CheckObjectPathExistencePathNotFound </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (s *fakeObjectStorageSession) CreateBucket(bucket, locationConstraint string, kpRootKeyCrn string) (string, error) <span class="cov0" title="0">{
        s.factory.LastCreatedBucket = bucket
        if s.factory.FailCreateBucket </span><span class="cov0" title="0">{
                return "", errors.New(s.factory.FailCreateBucketErrMsg)
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}

func (s *fakeObjectStorageSession) DeleteBucket(bucket string) error <span class="cov0" title="0">{
        s.factory.LastDeletedBucket = bucket
        if s.factory.FailDeleteBucket </span><span class="cov0" title="0">{
                return errors.New("")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *fakeObjectStorageSession) SetBucketVersioning(bucket string, enabled bool) (string, error) <span class="cov0" title="0">{
        s.factory.LastUpdatedBucket = bucket
        if s.factory.FailSetBucketVersioning </span><span class="cov0" title="0">{
                return "", errors.New("failed to set versioning")
        }</span>
        <span class="cov0" title="0">if enabled </span><span class="cov0" title="0">{
                return "Enabled", nil
        }</span>
        <span class="cov0" title="0">return "Suspended", nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Kubernetes Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2023 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package config

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/BurntSushi/toml"
        "github.com/IBM/ibmcloud-object-storage-plugin/utils/consts"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "os"
        "strconv"
        "strings"
        "time"
)

// ClusterInfo ...
type ClusterInfo struct {
        ClusterID   string `json:"cluster_id"`
        ClusterName string `json:"cluster_name,omitempty"`
        DataCenter  string `json:"datacenter,omitempty"`
        CustomerID  string `json:"customer_id,omitempty"`
}

func getEnv(key string) string <span class="cov10" title="17">{
        return os.Getenv(strings.ToUpper(key))
}</span>

func setEnv(key string, value string) <span class="cov7" title="8">{
        os.Setenv(strings.ToUpper(key), value)
}</span>

// GetGoPath ...
func GetGoPath() string <span class="cov3" title="2">{
        if goPath := getEnv("GOPATH"); goPath != "" </span><span class="cov1" title="1">{
                return goPath
        }</span>
        <span class="cov1" title="1">return ""</span>
}

// ParseConfig ...
func ParseConfig(filePath string, conf interface{}, logger zap.Logger) <span class="cov3" title="2">{
        if _, err := toml.DecodeFile(filePath, conf); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error parsing config file", zap.Error(err))
        }</span>
}

// GetConfigString ...
func GetConfigString(envKey, defaultConf string) string <span class="cov3" title="2">{
        if val := getEnv(envKey); val != "" </span><span class="cov1" title="1">{
                return val
        }</span>
        <span class="cov1" title="1">return defaultConf</span>
}

// GetConfigInt ...
func GetConfigInt(envKey string, defaulfConf int, logger zap.Logger) int <span class="cov3" title="2">{
        if val := getEnv(envKey); val != "" </span><span class="cov1" title="1">{
                if envInt, err := strconv.Atoi(val); err == nil </span><span class="cov1" title="1">{
                        return envInt
                }</span>
                <span class="cov0" title="0">logger.Error("error parsing env val to int", zap.String("env", envKey))</span>
        }
        <span class="cov1" title="1">return defaulfConf</span>
}

// GetConfigBool ...
func GetConfigBool(envKey string, defaultConf bool, logger zap.Logger) bool <span class="cov3" title="2">{
        if val := getEnv(envKey); val != "" </span><span class="cov1" title="1">{
                if envBool, err := strconv.ParseBool(val); err == nil </span><span class="cov1" title="1">{
                        return envBool
                }</span>
                <span class="cov0" title="0">logger.Error("error parsing env val to bool", zap.String("env", envKey))</span>
        }
        <span class="cov1" title="1">return defaultConf</span>
}

// GetConfigStringList ...
func GetConfigStringList(envKey string, defaultConf string, logger zap.Logger) []string <span class="cov3" title="2">{
        // Assume env var is a list of strings separated by ','
        val := defaultConf

        if getEnv(envKey) != "" </span><span class="cov1" title="1">{
                val = getEnv(envKey)
        }</span>

        <span class="cov3" title="2">val = strings.Replace(val, " ", "", -1)
        return strings.Split(val, ",")</span>
}

// SetUpEvn ... Export the configmap (eg. cluster-info) to environment variables
func SetUpEvn(kubeclient kubernetes.Interface, logger *zap.Logger) error <span class="cov6" title="5">{
        logger.Info("Entry SetUpEvn")

        //Read cluster meta info
        err := LoadClusterInfoMap(kubeclient, logger)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov4" title="3">logger.Info("Exit SetUpEvn")
        return err</span>
}

// LoadClusterInfoMap ... Read cluster metadata from 'cluster-info' map and load into ENV
func LoadClusterInfoMap(kubeclient kubernetes.Interface, logger *zap.Logger) error <span class="cov6" title="5">{
        logger.Debug("Entry LoadClusterInfoMap")

        //check if the ENV variable already loaded
        clusterid := getEnv("cluster_id")
        if len(clusterid) &gt; 0 </span><span class="cov1" title="1">{
                logger.Info("Exit LoadClusterInfoMap, cluster_id already set", zap.String("cluster_id", clusterid))
                return nil
        }</span>
        <span class="cov5" title="4">ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()
        // export cluster-info config map
        cmClusterInfo, err := kubeclient.CoreV1().ConfigMaps(consts.KubeSystem).Get(ctx, consts.ClusterInfo, metav1.GetOptions{})
        if err != nil </span><span class="cov1" title="1">{
                //err = fmt.Errorf("Unable to find the config map %s. Error: %v.Setting dummy values", consts.ClusterInfo, err)
                logger.Warn("Unable to find the config map %s. Error: %v.Setting dummy values", zap.Reflect(consts.ClusterInfo, err))

                setEnv("CLUSTER_ID", "dummyClusterID")
                setEnv("CLUSTER_NAME", "dummyClusterName")
                setEnv("DATACENTER", "dummyDC")
                setEnv("CUSTOMER_ID", "dummyCustomerID")
                return nil
        }</span>

        <span class="cov4" title="3">logger.Debug("configmap details", zap.Reflect(consts.ClusterInfo, cmClusterInfo))
        clusterInfoData := cmClusterInfo.Data[consts.ClusterInfoData]
        clusteInfo := ClusterInfo{}
        err = json.Unmarshal([]byte(clusterInfoData), &amp;clusteInfo)
        if err != nil </span><span class="cov1" title="1">{
                err = fmt.Errorf("Error while parsing cluster-config %s. Error: %v", consts.ClusterInfo, err)
                return err
        }</span>

        <span class="cov3" title="2">logger.Info("Exporting cluster-config", zap.Reflect(consts.ClusterInfo, clusteInfo))
        if clusteInfo.ClusterID == "" </span><span class="cov1" title="1">{
                err = fmt.Errorf("cluster_id is not found in map %s", consts.ClusterInfo)
                return err
        }</span>
        <span class="cov1" title="1">setEnv("CLUSTER_ID", clusteInfo.ClusterID)
        setEnv("CLUSTER_NAME", clusteInfo.ClusterName)
        setEnv("DATACENTER", clusteInfo.DataCenter)
        setEnv("CUSTOMER_ID", clusteInfo.CustomerID)
        logger.Debug("Exit LoadClusterInfoMap")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Kubernetes Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2023 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package fake_grpc

import (
        "errors"
        grpcClient "github.com/IBM/ibmcloud-object-storage-plugin/utils/grpc-client"
        "google.golang.org/grpc"
)

// FakeGrpcSessionFactory implements grpcClient.GrpcSessionFactory
type FakeGrpcSessionFactory struct {
        //FailGrpcConnection ...
        FailGrpcConnection bool
        //FailGrpcConnectionErr with specific error msg...
        FailGrpcConnectionErr string
        //PassGrpcConnection ...
        PassGrpcConnection bool
}

var _ grpcClient.GrpcSessionFactory = (*FakeGrpcSessionFactory)(nil)

// fakeGrpcSession implements grpcClient.GrpcSession
type fakeGrpcSession struct {
        factory *FakeGrpcSessionFactory
}

// NewGrpcSession method creates a new fakeGrpcSession session
func (f *FakeGrpcSessionFactory) NewGrpcSession() grpcClient.GrpcSession <span class="cov0" title="0">{
        return &amp;fakeGrpcSession{
                factory: f,
        }
}</span>

// GrpcDial method creates a fake-grpc-client connection
func (c *fakeGrpcSession) GrpcDial(clientConn grpcClient.ClientConn, target string, opts ...grpc.DialOption) (conn *grpc.ClientConn, err error) <span class="cov0" title="0">{
        if c.factory.FailGrpcConnection </span><span class="cov0" title="0">{
                return conn, errors.New(c.factory.FailGrpcConnectionErr)
        }</span>
        <span class="cov0" title="0">return conn, err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Kubernetes Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2023 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package grpc_client

import (
        "google.golang.org/grpc"
)

type GrpcSessionFactory interface {
        NewGrpcSession() GrpcSession
}

type GrpcSession interface {
        GrpcDial(cc ClientConn, target string, opts ...grpc.DialOption) (*grpc.ClientConn, error)
}

type ConnObjFactory struct{}

type ClientConn interface {
        Connect(target string, opts ...grpc.DialOption) (*grpc.ClientConn, error)
        //Close() error
}

type GrpcSes struct {
        conn *grpc.ClientConn
        cc   ClientConn
}

func (gs *GrpcSes) Connect(target string, opts ...grpc.DialOption) (*grpc.ClientConn, error) <span class="cov0" title="0">{
        var err error
        gs.conn, err = grpc.Dial(target, opts...)
        return gs.conn, err
}</span>

//func (gs *GrpcSes) Close() error {
//        if gs.conn != nil {
//                return gs.conn.Close()
//        }
//        return nil
//}

func (c *ConnObjFactory) NewGrpcSession() GrpcSession <span class="cov1" title="1">{
        return &amp;GrpcSes{}
}</span>

//var cc ClientConn = &amp;GrpcSes{}

// GrpcDial establishes a grpc-client client server connection
func (c *GrpcSes) GrpcDial(cc ClientConn, target string, opts ...grpc.DialOption) (*grpc.ClientConn, error) <span class="cov10" title="2">{
        conn, err := cc.Connect(target, opts...)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return conn, err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/******************************************************************************r
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package logger

import (
        "context"
        "errors"
        "github.com/IBM/ibmcloud-object-storage-plugin/utils/consts"
        uid "github.com/gofrs/uuid"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "os"
)

const (
        // PodName is the zap field key label for pod name
        PodName = "podName"
)

// ZapLogger is the global logger
var ZapLogger *zap.Logger

// GetZapLogger returns an instance of the logger, initializing a new logger
func GetZapLogger() (*zap.Logger, error) <span class="cov10" title="15">{
        if ZapLogger == nil </span><span class="cov10" title="15">{
                return NewZapLogger()
        }</span>
        <span class="cov0" title="0">return ZapLogger, nil</span>
}

// GetZapContextLogger Creates a new logger based from the global logger and adds values from the
// context as logging fields. If the context passed in is null then it
// returns the global logger
func GetZapContextLogger(ctx context.Context) (*zap.Logger, error) <span class="cov3" title="2">{
        var contextLogger *zap.Logger
        globalLogger, _ := GetZapLogger()
        if ctx != nil </span><span class="cov1" title="1">{
                contextLogger = addContextFields(ctx, globalLogger)
                return contextLogger, nil
        }</span>
        <span class="cov1" title="1">return globalLogger, nil</span>
}

// GetZapDefaultContextLogger Creates a new logger based from the global logger and adds RequestID from the
// context as logging field.
func GetZapDefaultContextLogger() (*zap.Logger, error) <span class="cov1" title="1">{
        var contextLogger *zap.Logger
        globalLogger, _ := GetZapLogger()
        contextLogger = addContextFields(generateContextWithRequestID(), globalLogger)
        return contextLogger, nil
}</span>

// GetZapContextLoggerFromLogger creates a new logger based from an existing logger and adds values from the
// context as logging fields. If the context passed in is null then it
// returns the global logger
func GetZapContextLoggerFromLogger(ctx context.Context, origLogger *zap.Logger) (*zap.Logger, error) <span class="cov5" title="4">{
        var contextLogger *zap.Logger
        if origLogger == nil </span><span class="cov3" title="2">{
                return origLogger, errors.New("a valid logger needs to be passed in")
        }</span>
        <span class="cov3" title="2">if ctx != nil </span><span class="cov1" title="1">{
                contextLogger = addContextFields(ctx, origLogger)
                return contextLogger, nil
        }</span>
        <span class="cov1" title="1">return origLogger, nil</span>
}

// Adds fields to an existing logger using values in the context
func addContextFields(ctx context.Context, origLogger *zap.Logger) *zap.Logger <span class="cov6" title="5">{
        if _, ok := ctx.Value(consts.TriggerKeyLabel).(string); ok </span><span class="cov1" title="1">{
                origLogger = origLogger.With(CreateZapTiggerKeyField(ctx))
        }</span>
        <span class="cov6" title="5">if _, ok := ctx.Value(consts.RequestIDLabel).(string); ok </span><span class="cov6" title="5">{
                origLogger = origLogger.With(CreateZapRequestIDField(ctx))
        }</span>
        <span class="cov6" title="5">return origLogger</span>
}

// NewZapLogger creates and returns a new global logger. It overwrites the
// existing global logger if that has been previously defined.
func NewZapLogger() (*zap.Logger, error) <span class="cov10" title="15">{
        productionConfig := zap.NewProductionConfig()
        productionConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        ZapLogger, _ := productionConfig.Build()
        return ZapLogger, nil
}</span>

// CreatePodNameLogger takes a zap logger and adds a pod name field
// NOTE: the logger returned is a different logger from the one passed in
func CreatePodNameLogger(logger *zap.Logger) (*zap.Logger, error) <span class="cov4" title="3">{
        if logger == nil </span><span class="cov1" title="1">{
                return nil, errors.New("logger passed in can not be null")
        }</span>
        <span class="cov3" title="2">podNameField := CreateZapPodNameKeyField()
        return logger.With(podNameField), nil</span>
}

// CreateZapRequestIDField Creates a zap logger field containing the request ID, convenience method for creating the
// field in cases where the ContextLogger can't be used and the field needs to be passed
// in as a parameter in the logging statements
func CreateZapRequestIDField(ctx context.Context) zapcore.Field <span class="cov7" title="8">{
        if ctx != nil </span><span class="cov7" title="7">{
                if requestID, ok := ctx.Value(consts.RequestIDLabel).(string); ok </span><span class="cov6" title="6">{
                        return zapcore.Field{Key: consts.RequestIDLabel, Type: zapcore.StringType, String: requestID}
                }</span>
        }
        <span class="cov3" title="2">return zapcore.Field{Key: consts.RequestIDLabel, Type: zapcore.StringType, String: ""}</span>
}

// CreateZapTiggerKeyField Creates a zap logger field containing the trigger key for a job, convenience method for creating the
// field in cases where the ContextLogger can't be used and the field needs to be passed
// in as a parameter in the logging statements
func CreateZapTiggerKeyField(ctx context.Context) zapcore.Field <span class="cov5" title="4">{
        if ctx != nil </span><span class="cov4" title="3">{
                if triggerKey, ok := ctx.Value(consts.TriggerKeyLabel).(string); ok </span><span class="cov3" title="2">{
                        return zapcore.Field{Key: consts.TriggerKeyLabel, Type: zapcore.StringType, String: triggerKey}
                }</span>
        }
        <span class="cov3" title="2">return zapcore.Field{Key: consts.TriggerKeyLabel, Type: zapcore.StringType, String: ""}</span>
}

// CreateZapPodNameKeyField Creates a zap logger field containing the pod name that the container is in,
// convenience method for creating the field so it can be passed
// in as a parameter in the logging statements
func CreateZapPodNameKeyField() zapcore.Field <span class="cov5" title="4">{
        pod := os.Getenv(consts.PodNameEnvVar)
        // if the pod name isn't set then the value will be empty
        return zapcore.Field{Key: PodName, Type: zapcore.StringType, String: pod}
}</span>

// Creates a context that contains a unique request ID
func generateContextWithRequestID() context.Context <span class="cov3" title="2">{
        reqID, _ := uid.NewV4()
        requestID := reqID.String()
        return context.WithValue(context.Background(), consts.RequestIDLabel, requestID)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package parser

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net"
        "strings"
)

// DecodeBase64 decodes a base64 string
func DecodeBase64(encoded string) (string, error) <span class="cov4" title="2">{
        bytes, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov1" title="1">return string(bytes), nil</span>
}

// UnmarshalMap unmarshal a map[string]string to an interface (via JSON decoding)
func UnmarshalMap(m *map[string]string, v interface{}) error <span class="cov4" title="2">{
        jsonBytes, err := json.Marshal(*m)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot marshal map: %v", err)
        }</span>
        <span class="cov4" title="2">err = json.Unmarshal(jsonBytes, v)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot unmarshal '%s': %v", string(jsonBytes), err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// MarshalToMap converts an interface to map[string]string (via JSON encoding)
func MarshalToMap(v interface{}) (map[string]string, error) <span class="cov8" title="4">{
        var m map[string]interface{}

        jsonString, err := json.Marshal(v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("cannot marshal object: %v", err)
        }</span>
        <span class="cov7" title="3">err = json.Unmarshal([]byte(jsonString), &amp;m)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("cannot unmarshal '%s' to map: %v", jsonString, err)
        }</span>

        <span class="cov4" title="2">res := make(map[string]string)

        for k, v := range m </span><span class="cov4" title="2">{
                stringVal, ok := v.(string)
                if !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("cannot convert value to string: %v", v)
                }</span>
                <span class="cov1" title="1">res[k] = stringVal</span>
        }
        <span class="cov1" title="1">return res, nil</span>
}

// parse ips passed in string format
func ParseIPs(ips string) (bool, []string) <span class="cov4" title="2">{
        var invalidIpArr []string
        ipArray := strings.Split(ips, ",")
        for _, ip := range ipArray </span><span class="cov10" title="5">{
                ip = strings.TrimSpace(ip)
                if ip != "" </span><span class="cov10" title="5">{
                        if net.ParseIP(ip) == nil </span><span class="cov4" title="2">{
                                invalidIpArr = append(invalidIpArr, ip)
                        }</span>
                }
        }

        <span class="cov4" title="2">if len(invalidIpArr) == 0 </span><span class="cov1" title="1">{
                return true, nil
        }</span> else<span class="cov1" title="1"> {
                return false, invalidIpArr
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2017, 2018 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package uuid

import (
        "crypto/rand"
        "fmt"
        "io"
)

// Generator generates UUID strings
type Generator interface {
        // New generates a random UUID according to RFC 4122
        New() (string, error)
}

// ReaderGenerator generates UUID strings using an IO reader
type ReaderGenerator struct {
        // Reader is the entropy source for the UUID generator
        Reader io.Reader
}

// NewCryptoGenerator returns new cryptographic UUID generator
func NewCryptoGenerator() *ReaderGenerator <span class="cov1" title="1">{
        return &amp;ReaderGenerator{Reader: rand.Reader}
}</span>

// New generates a random UUID according to RFC 4122
func (u *ReaderGenerator) New() (string, error) <span class="cov10" title="101">{
        uuid := make([]byte, 16)
        n, err := io.ReadFull(u.Reader, uuid)
        if n != len(uuid) || err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        // variant bits; see section 4.1.1
        <span class="cov9" title="100">uuid[8] = uuid[8]&amp;^0xc0 | 0x80
        // version 4 (pseudo-random); see section 4.1.3
        uuid[6] = uuid[6]&amp;^0xf0 | 0x40
        return fmt.Sprintf("%x-%x-%x-%x-%x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:]), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
